<!DOCTYPE html>
<html>
  <head>
    <title>Timing Object</title>
    <meta charset="utf-8">
    <script src="https://www.w3.org/Tools/respec/respec-w3c-common"
            async class="remove"></script>
    <script class="remove">
      var respecConfig = {
          specStatus: "CG-DRAFT",
          edDraftURI: "https://webtiming.github.io/timingobject",
          shortName:  "timing-object",
          editors: [
            {
              name:       "Ingar M. Arntzen",
              company:    "Norut Northern Research Institute and Motion Corporation",
              companyURL: "https://motioncorporation.com/",
              mailto: "ingar.arntzen@motioncorporation.com"
            },
            {
              name:       "François Daoust",
              company:    "W3C",
              companyURL: "https://www.w3.org",
              mailto:     "fd@w3.org"
            }
          ],
          authors: [
            {
              name:       "Njål T. Borch",
              company:    "Norut Northern Research Institute and Motion Corporation",
              companyURL: "https://motioncorporation.com/",
              mailto: "njaal.borch@motioncorporation.com"
            }
          ],
          wg:           "Multi-Device Timing Community Group",
          wgURI:        "https://www.w3.org/community/webtiming/",
          wgPublicList: "public-webtiming",

          localBiblio:  {
            "LINEARCOMPOSITION": {
              title: "Multi-device Linear Composition on the Web: Enabling Multi-device Linear Media with HTMLTimingObject and Shared Motion",
              href: "https://sites.google.com/site/mediasynchronization/Paper4_Arntzen_webComposition_CR.pdf?attredirects=0&d=1",
              authors: [
                "Ingar M. Arntzen",
                "Njål T. Borch",
                "François Daoust",
                "Dominique Hazaël-Massieux"
              ]
            },
            "MSV": {
              title:    "The Media State Vector: A unifying concept for multi-device media navigation",
              href:     "https://dl.acm.org/citation.cfm?doid=2457413.2457427",
              authors:  [
                "Ingar M. Arntzen",
                "Njål T. Borch",
                "Christopher P. Needham"
              ]
            },
            "DVB-CSS": {
              title: "ETSI TS 103 286-2 V1.1.1 Digital Video Broadcasting (DVB); Companion Screens and Streams; Part 2: Content Identification and Media Synchronization",
              href: "https://www.etsi.org/deliver/etsi_ts/103200_103299/10328602/01.01.01_60/ts_10328602v010101p.pdf"
            },
            "SHAREDMOTION": {
              title: "Shared Motion",
              href: "https://motioncorporation.com"
            },
            "MEDIASYNC":{
              title: "MediaSync",
              href: "https://github.com/webtiming/mediasync"
            },
            "SEQUENCER" : {
              title: "Open-source sequencer library",
              href: "https://github.com/webtiming/sequencer"
            }
          },
          otherLinks: [
            {
              key: "Version history",
              data: [
                {
                  value: "GitHub webtiming/timingobject/commits",
                  href: "https://github.com/webtiming/timingobject/commits/"
                }
              ]
            },
            {
              key: "Participate",
              data: [
                {
                  value: "GitHub webtiming/timingobject",
                  href: "https://github.com/webtiming/timingobject/"
                },
                {
                  value: "File an issue",
                  href: "https://github.com/webtiming/timingobject/issues/new"
                },
                {
                  value: "Open issues",
                  href: "https://github.com/webtiming/timingobject/issues/"
                },
                {
                  value: "Mailing-list (public-webtiming@w3.org)",
                  href: "https://lists.w3.org/Archives/Public/public-webtiming/"
                }
              ]
            }
          ],

          issueBase: "https://www.github.com/webtiming/timingobject/issues/",
          githubAPI: "https://api.github.com/repos/webtiming/timingobject"
      };
    </script>
    <style type="text/css">
      table { border-collapse: collapse; border-style: hidden hidden none hidden; }
      table thead, table tbody { border-bottom: solid; }
      table td, table th { border-left: solid; border-right: solid; border-bottom: solid thin; vertical-align: top; padding: 0.2em; }
    </style>
  </head>
  <body>



    <!-- ABSTRACT -->

    <section id="abstract">
      <p>
        This specification defines the timing object. The timing object is a local object that may be used by Web clients to ensure precisely timed operation as well as flexible timing control. If multiple timing-sensitive components take direction from the same timing object, their behaviour will be precisely aligned in time (synchronized). Crucially, this is also the case in distributed settings. A central motivation for the timing object is that it may be connected to an online timing resource. This way, the local timing object is a gateway to precisely timed operations, both in single-device and multi-device scenarios.
      </p>
  

      <p class="note">
        This timing object is not to be confused with concepts proposed by 
        <a href="https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/NavigationTiming/Overview.html">Navigation Timing</a>, an initiative targeting precise measurement of time consumption in Web browsers.
      </p>

    </section>




    <!-- STATUS OF DOCUMENT -->

    <section id="sotd">
      <p>
        The specification is intended for discussion within the Multi-Device Timing Community Group. Its content does not yet represent the consensus of the Community Group.
      </p>
      <p class="warning">
        This specification is incomplete. Some procedures are either missing or described as <em>similar to procedures defined in [[HTML5]]</em>. The main goal of this draft is to propose a technical solution, show how it could be integrated in [[HTML5]] and gather feedback from interested parties before dwelving into details.
      </p>
    </section>
    



    <!-- INTRODUCTION -->

    <section class="informative">
      <h2>Introduction</h2>
      
      <p>
        Timing mechanisms allow operations to be executed at the correct time. The Web already has several mechanisms supporting timed operations, including <code>setTimeout</code>, <code>setInterval</code>, as well as media frameworks and animation frameworks for timed media presentation. Unfortunately, these mechanisms are limited in scope as they only apply to timed operations within a single web page. The <a href="https://www.w3.org/community/webtiming/">W3C Multi-device Timing Community Group</a> has been formed with the goal of extending the Web with native support for precisely timed operation across Web pages hosted by different devices, as well as providing a unifying timing model to which all frameworks for timed operation may integrate. The timing object is the central concept in this initiative.
      </p>

      <p>
        Synchronized playback of multi-device linear media is an important use-case for multi-device timing. However, multi-device timing has wide utility for a variety of timing related challenges, including distributed media control and remote control, distributed synchronization, distributed time-shifting, distributed time-ordering and distributed capture/recording (time-stamping). This way, multi-device timing has applicability in many application domains, including TV and radio (broadcast and IP-based), secondary device applications, online education, VoD services, social and collaborative media, data visualization, music etc.
      </p>
      <p>
        For a more detailed list of use cases that this specification enables, see <a href="#use-cases-and-requirements"></a>.
      </p>


      <section>
        <h3>Linear composition</h3>

        <p>
          <dfn data-lt="linear composition|linear composability">Linear composition</dfn> or <dfn>temporal composition</dfn> is simply the idea that complex linear media can be built from simpler, independent linear components. Web support for linear composition would imply that classical benefits of composition, i.e. flexibility, reusability, extensibility and mashup-ability, apply to the construction of Web-based linear media. For example, in the single-device scenario, imagine a linear presentation made from HTML5 video, some timed meta-information, a SMIL component, a Web Animation, a map with timed georeferenced data, and a timed Twitter widget. Or, in the multi-device scenario, imagine the same components distributed or duplicated across multiple devices in a room or within a social group. In both cases linear composition requires temporal interoperability among heterogeneous linear components, available through precisely coordinated, timed playback.
        </p>
        <p>
          Unfortunately, Web support for linear composition is not optimal. Each media framework tends to define its own custom timing control mechanisms, making it difficult to achieve <a>linear composition</a> in practice. The central purpose of the timing object is thus to simplify interoperability by providing a common basis for timed operation and control in linear media.
        </p>
        <p>
          For a more detailed introduction to linear composition on the Web, see [[LINEARCOMPOSITION]].
        </p>
      </section>

      <section>
        <h3>Design goals</h3>

        <p>
          The design of the timing object has two main goals:
        </p>
        <ol>
          <li>
            <b>provide a unifying API for timed operation and temporal control</b> that timed components can integrate with. This would include timing sensitive Web applications in general, as well as existing frameworks for timed media &mdash; such as <a>media elements</a> in [[HTML5]], Web Animations [[WEB-ANIMATIONS-1]], Web Audio API [[WEBAUDIO]] and SMIL Timing [[SMIL3]]. The API must support highly precise timing and be expressive enough to support control primitives appropriate for a wide range of media types and applications.
          </li>
          <li> 
            <b>encapsulate complexity of distributed time synchronization</b>, thereby allowing integrating frameworks to be included in precisely timed multi-device operation. In particular, by providing the same API for local and online timing resources, timed components may be used in single-device and multi-device scenarios, without modification. 
          </li>
        </ol>

        <p>
          <a href="#fig-timingobject-overview">Fig. 1</a> illustrates these functions, including an online service to provide multi-device timing. In this example, a timing object is instantiated on each of the three devices, and each instance is connected to a single, shared online timing resource. On each device, the timing object acts as the director for independent, timing-sensitive User Interface (UI) components. This way, a video will aim to present video frames in accordance with the timing resource. Similarly, a timing-sensitive Twitter widget might replay timestamped Tweets. If the timing object pauses, all the connected components are notified and react accordingly. Note that the different UI components may go about their business in complete isolation. There is no need for components to communicate, except indirectly through the timing object. This loose coupling is the key to <a>linear composability</a>.
        </p>

        <figure id="fig-timingobject-overview">
          <img src="overview.png" width="400" alt="The image illustrates the concept of an online timing resource how it used to synchronize HTTPTimingObjects across three different Web clients." />
          <figcaption>Timing objects on three devices connected to the same online timing resource</figcaption>
        </figure>

        <p>
          Furthermore, when timing objects are connected to an online timing resource, they merely act as local representatives. For example, when requested to pause, the timing object will simply forward the request to the online timing resource. As the online object pauses, notifications will be multicast to all connected clients. The timing object will only update its internal state and notify connected UI components when it receives this notification. For online timing objects, clients can expect update latency of about one round trip time (RTT), whereas local timing resources should have no update latency. Apart from this, online and local timing resources should be hard to distinguish. Note also that the argument made for the independence of timing-sensitive components in the single-device scenario now applies to the multi-device scenario as well. 
        </p>

        <p class="note">
          This specification describes the integration of timing objects with HTML5 Media elements and text tracks. Integration with other frameworks for timed operation, such as Web Animation, SMIL, and WebAudio will be covered separately.
        </p>
      </section>



      




      <section>
        <h3>The timing object</h3>
        <p>
          The timing object is a very simple object, essentially an advanced stop watch (<a href="#fig-stopwatch">Fig. 2</a>). If started, its value changes predictably in time, until at some point later, it is paused, or perhaps reset. It may be queried for its value at any time. For example, it should take exactly 2.0 seconds for the value to advance from 3.0 to 5.0 when the velocity is 1.0. Such deterministic behavior is required for reliable distributed synchronization. In terms of implementation, the timing object is a fairly thin wrapping around a monotonic system clock (integration with online timing resources adds complexity). The precision of the timing object is limited by the underlying system clock.
        </p>
        <figure id="fig-stopwatch">
          <img src="stopwatch_digital.jpg" width="160" alt="The timing object is essentially an advanced stop watch." />
          <figcaption>The timing object is essentially an advanced stop watch.</figcaption>
        </figure>

        <p>
          The timing object is more expressive than a traditional stop watch. It supports any velocity or acceleration, and may jump (instantaneously) to any position on the timeline (<a href="#fig-timeline">Fig. 3</a>). In fact, a timing object essentially implements <em>linear motion along a unidimensional axis</em>. State vectors [[MSV]], based on the classical equations of linear motion under constant acceleration, are used to represent that motion. At any point in time, position, velocity or acceleration may be requested to change. Querying the timing object reveals not only its current position but also its velocity and acceleration at that moment. The expressiveness of this model implies that a wide variety of control primitives can be supported. For example, discrete jumps on the timeline may be used to control a slide show, or velocity may correspond to <code>playbackRate</code> for the control of continuous media. Acceleration may be for instance be required by animation frameworks.
        </p>

        <figure id="fig-timeline">
          <img src="timeline.png" width="400" alt="The timing object is essentially and advanced stop watch." />
          <figcaption>The timing object visualized as a cursor moving along a time-axis.</figcaption>
        </figure>
      </section>

      <section>
        <h3>Programming with timing objects</h3>

        <p>
          Timing objects are resources used by a Web application, and the programmer may define as many as required. What purposes they serve in the application is up to the programmer. If the application needs a shared, multi-device clock, simply starting a timing object (and never stopping it) might be sufficient. If the clock value should represent milliseconds, set the velocity to 1000 (advances the timing object with 1000 milliseconds per second). If the timing object represents media offset, specify the playback position, the velocity, and perhaps a media duration. For videos where offset is measured in seconds or frames, set the velocity accordingly. Or, for musical applications it may be practical to let the timing object represent beats per second. Note also that the timing object may represent time-changes with any kind of floating-point variable. For example, if you have data that is organized according to, say height above sea level, you may want to animate how this data changes as you move vertically. In this case the timing object could represent meters or feet above sea level, and positive and negative velocities would allow you to move gradually both upwards and downwards.
        </p>
        <p>
          In general, the timing object is particularly useful when you have a variable that needs to change predictably in time.
        </p>
      </section>

      <section>
        <h3>Connecting the timing object</h3>

        <p>
          The proposed timing model is one where timed components are <i>connected</i> to <a>timing objects</a>, thereby accepting the <a>timing object</a> as director of timed operation. In other words, the <a>timing object</a> is the master, and the timed component is the slave. However, the <i>connection</i> is not entirely one-way. Timed components may also enforce control over the <a>timing object</a> by issuing update requests. This allows interactive components to implement timing control on behalf of end users. For instance, a UI element implementing media controls may both be a slave of a <a>timing object</a> by slavishly visualizing media offset, while at the same time allow the end user to pause the presentation by clicking a the pause button. Crucially, control enforced on a <a>timing object</a> applies equally on all <i>connected</i> components.
        </p>

        <p>
          Flexibility is another feature with this timing model. Since the <a>timing object</a> is an independent object, timed components and <a>timing objects</a> may be <i>connected</i> and <i>disconnected</i> dynamically. For example, in the context of live media presentation, flexible switching may be enabled between a <a>timing object</a> (representing the <i>public, live-head</i> of an experience), and a different <a>timing object</a> (representing <i>private, personal, time-shifted</i> experience). Another example would be switching to a different <a>timing object</a> in order to join a friend in a co-viewing session. 
        </p>
      
        <p>
          To support this timing model, a clear separation between <a>timing object</a> and consuming components is required. Specifically, a pattern emerges where timed components are given a reference to a <a>timing object</a> through a <code>timingsrc</code> property. On the other hand the <a>timing object</a> is kept usage agnostic and clean of references to consuming components.
        </p>

        <p>
          Timed components that need to <i>connect</i> with the <a>timing object</a> broadly fall into two categories: components which already have an internal timing model, and components that do not. Within the first category we specifically have media players and existing media frameworks. For such components <i>connection</i> with the <a>timing object</a> mainly implies time-alignment of the internal timing model with the external <a>timing object</a>. In particular, this document discusses integration with <a>media elements</a>, see <a href="#media-elements-and-the-timing-object"></a>. 
        </p>

        <p>
          Components within the second category do not provide their own timing model, but may be useful for presenting timed data. UI elements such as map and canvas fall into this category. Custom components such as plotting libraries, media controls, subtitle viewers, Twitter widgets etc., may also need to <i>connect</i> with a <a>timing object</a> (in order to present data consistently in time). In fact, an entire Web page may be considered a timed component, where replacement of both data and presentational elements is directed by a <a>timing object</a>. All these timed components have a single challenge in common, the need to present or execute timed data at the correct time, i.e. time-aligned with the <a>timing object</a>. This document addresses this common need by <i>connecting</i> the <a>timing object</a> with a <a>text track</a>, see <a href="#timed-data-and-the-timing-object"></a>.
        </p>

        <p>
          Finally, in order to support precisely timed operation in multi-device applications, the <a>timing object</a> must be <i>connected</i> with an <a>online timing resource</a>. One could imagine future standardization of a protocol between <a>timing object</a> and the online timing service. Currently though, the decision is rather to leave space open for innovation among timing providers. The <a>TimingProvider</a> interface is introduced, see <a href="#timing-provider-object"></a>. The idea is that third-parties may provide different implementations of <a>timing provider objects</a> (in JavaScript), to which <a>timing objects</a> may then connect. As a result, the <i>connection</i> to a <a>timing provider object</a> may be provided by the inclusion of a third-party JavaScript library.
        </p>
        
      </section>


      <section>
        <h3>Media capture and playback</h3>

        <p>
          Two very common uses of the timing object include media capture and playback. For media playback, the  timing object may play the role of director or controls. Multiple independent components, possibly on different devices, may be responsible for timed presentation of timed media. If all components take direction from a single timing object, playback is ensured to be timing-consistent.
        </p>
        <p>
          For media capture, the timing object may represent a shared clock for timestamping various types of captured media in multi-device scenarios. As long as timestamps are sampled from a shared clock and included in the captured media, time-shifted playback is possible. In live capturing scenarios, the timing object should likely just run continuously like a clock, or perhaps be adjusted slightly from time to time to stay in sync with some real-world clock source, e.g. a trusted source for epoch time. On the other hand, media capture in a studio setting may be a much more of an iterative process, recording one track or sample at a time. In such scenarios, the timing object might have to be paused and rewound for each take. The timing object will then play the dual role of playback director for previously captured media, as well as production clock for current capture.
        </p>
      </section>

      <section>
        <h3>Reference point in capture and playback</h3>

        <p>
          The concept of reference point refers to the exact time-alignment of timing object and media in capture and playback. Disagreement about the details of this alignment may be a source of (small) synchronization errors. For this reason, a common definition of reference points for time alignment in capture and playback is helpful.
        </p>
        <p>
          For media capture, media timestamps should reflect the point in time when external, physical signals are received by sensors, i.e. ideally when photons hit the lense or when sound waves hit the microphone. As timestamping activity is delayed relative to this ideal reference point, timestamps picked from the timing object must be adjusted (upstream delay subtracted). This implies that capturing components must know (or figure out) their upstream latency (if significant). If all components are able to do this correctly, variation in processing delay will not produce synchronization errors.
        </p>
        <p>
          For media playback, media timestamps should reflect the point in time when timed media fragments take physical effect. I.e., ideally when pixels are modified on the screen, or when the loudspeaker modifies its vibration frequency. If playback commands are subject to non-negligible delay before they take effect, the playback component must schedule commands earlier. This implies that playback component must know (or figure out) their downstream delay. If all components are able to do this correctly, variation in processing delay will not produce synchronization errors.
        </p>
        <p class="note">
          This definition of reference points is in accordance with definitions used in related standardization work, for instance see [[DVB-CSS]] / HbbTV2.0 CSS clause 5.7.2.
        </p>
        <p class="note">
          Strictly speaking, the timing object is usage-agnostic and can not mandate a specific definition for reference point. However, as interoperability of timing-sensitive components (e.g. capture and playback) is a major motivation for the timing object, the above definitions for reference point are recommended.  
        </p>
      </section>

       <section>
        <h3>Naming</h3>
        <p>
          With regards to the naming of the <a>timing object</a>, there were multiple options available, e.g. <i>Clock</i>, <i>WebClock</i>, <i>MediaClock</i> or <i>SharedClock</i>. For a descriptive name, we argue that <i>clock</i> (or variations thereof) might be a bit limiting. A <i>clock</i> (in particular a system clock) is mainly a read-only resource (from the perspective of the programmer). <i>Stop-watch</i> would better indicate the interactive nature of the <a>timing object</a>, however, this too would fail to indicate the role of the <a>timing object</a> as <i>controller</i> or <i>director</i> in media. From a purely descriptive point of view, deterministic <i>motion</i> is perhaps the most precise name, matching the implementation and also indicating that linear media is made from two basic constituents - media <i>content</i> and media <i>motion</i>. On the other hand, the term <i>motion</i> is (still) unfamiliar and does not indicate any specific uses. For these reasons it was decided to name the object after its main purpose which is correct timing and temporal control. Something like <i>TemporalControllerObject</i> or <i>TimingDirectorObject</i> would perhaps be most correct. However, as these terms are a bit clunky <i>TimingObject</i> was selected as an acceptable compromise.
        </p>
      </section>

    </section>




    <!-- CONFORMANCE -->

    <section id="conformance">
      <p>
        Requirements phrased in the imperative as part of algorithms (such as "strip any leading space characters" or "return false and terminate these steps") are to be interpreted with the meaning of the key word ("must", "should", "may", etc.) used in introducing the algorithm.
      </p>

      <p>
        Conformance requirements phrased as algorithms or specific steps may be implemented in any manner, so long as the end result is equivalent. (In particular, the algorithms defined in this specification are intended to be easy to follow, and not intended to be performant).
      </p>

      <p>
        This specification defines conformance criteria for two classes of products:
      </p>

      <ul>
        <li>A <dfn>user agent</dfn> that provides the Web runtime and implements all the interfaces defined in <a href="#timing-object"></a>, <a href="#state-vector"></a>, <a href="#media-elements-and-the-timing-object"></a> and <a href="#timed-data-and-the-timing-object"></a>.</li>
        <li>A <dfn>timing resource provider</dfn> that provides necessary logic to associate a <a>timing object</a> with an online <a>timing resource</a>. A <a>timing resource provider</a> implements the <code><a>TimingProvider</a></code> interface defined in <a href="#timing-provider-object"></a>.</li>
      </ul>
    </section>




    <!-- TERMINOLOGY -->

    <section>
      <h2>Terminology</h2>

      <p>
        The following terms, procedures and interfaces are defined in [[!HTML5]]:
      </p>
      <ul>
        <li><dfn data-lt="event handler|event handlers"><a href="https://www.w3.org/html/wg/drafts/html/master/webappapis.html#event-handlers">event handler</a></dfn></li>
        <li><dfn data-lt="event handler event type|event handler event types"><a href="https://www.w3.org/html/wg/drafts/html/master/webappapis.html#event-handler-event-type">event handler event type</a></dfn></li>
        <li><dfn><a href="https://www.w3.org/html/wg/drafts/html/master/webappapis.html#queue-a-task">queue a task</a></dfn></li>
        <li><dfn><a href="https://www.w3.org/html/wg/drafts/html/master/webappapis.html#fire-a-simple-event">fire a simple event</a></dfn></li>
        <li><dfn data-lt="media element|media elements"><a href="https://www.w3.org/html/wg/drafts/html/master/webappapis.html#media-element">media element</a></dfn></li>
        <li><dfn><a href="https://www.w3.org/html/wg/drafts/html/master/webappapis.html#media-timeline">media timeline</a></dfn></li>
        <li><dfn><a href="https://www.w3.org/html/wg/drafts/html/master/webappapis.html#effective-playback-rate">effective playback rate</a></dfn></li>
        <li><dfn><a href="https://www.w3.org/html/wg/drafts/html/master/webappapis.html#current-media-controller">current media controller</a></dfn></li>
        <li><dfn><a href="https://www.w3.org/html/wg/drafts/html/master/webappapis.html#slaved-media-elements">slaved media elements</a></dfn></li>
        <li><dfn><a href="https://www.w3.org/html/wg/drafts/html/master/webappapis.html#report-the-controller-state">report the controller state</a></dfn></li>
        <li><dfn><a href="https://www.w3.org/html/wg/drafts/html/master/webappapis.html#seek">seek</a></dfn></li>
        <li><dfn><a href="https://www.w3.org/html/wg/drafts/html/master/webappapis.html#media-data">media data</a></dfn></li>
        <li><dfn data-lt="text tracks"><a href="https://www.w3.org/html/wg/drafts/html/master/webappapis.html#text-track">text track</a></dfn></li>
        <li><dfn data-lt="text track cue|text track cues"><a href="https://www.w3.org/html/wg/drafts/html/master/webappapis.html#text-track-cue">text track cue</a></dfn></li>
        <li><dfn><a href="https://www.w3.org/html/wg/drafts/html/master/webappapis.html#text-track-kind">text track kind</a></dfn></li>
        <li><dfn><a href="https://www.w3.org/html/wg/drafts/html/master/webappapis.html#text-track-label">text track label</a></dfn></li>
        <li><dfn><a href="https://www.w3.org/html/wg/drafts/html/master/webappapis.html#text-track-language">text track language</a></dfn></li>
        <li><dfn><a href="https://www.w3.org/html/wg/drafts/html/master/webappapis.html#text-track-mode">text track mode</a></dfn></li>
        <li><dfn><a href="https://www.w3.org/html/wg/drafts/html/master/webappapis.html#text-track-hidden">text track hidden</a></dfn></li>
        <li><dfn><a href="https://www.w3.org/html/wg/drafts/html/master/webappapis.html#text-track-loaded">text track loaded</a></dfn></li>
        <li><dfn><a href="https://www.w3.org/html/wg/drafts/html/master/webappapis.html#text-track-readiness-state">text track readiness state</a></dfn></li>
        <li><dfn><a href="https://www.w3.org/html/wg/drafts/html/master/webappapis.html#text-track-list-of-cue">text track list of cues</a></dfn></li>
        <li><dfn><a href="https://www.w3.org/html/wg/drafts/html/master/webappapis.html#list-of-text-tracks">list of text tracks</a></dfn></li>
        <li><dfn><a href="https://www.w3.org/html/wg/drafts/html/master/webappapis.html#list-of-newly-introduced-cues">list of newly introduced cues</a></dfn></li>
        <li><dfn><a href="https://www.w3.org/html/wg/drafts/html/master/webappapis.html#current-playback-position">current playback position</a></dfn></li>
        <li><dfn><a href="https://www.w3.org/html/wg/drafts/html/master/webappapis.html#time-marches-on">time marches on</a></dfn></li>
        <li><dfn><code><a href="https://www.w3.org/html/wg/drafts/html/master/webappapis.html#eventhandler">EventHandler</a></code></dfn></li>
        <li><dfn><code><a href="https://www.w3.org/html/wg/drafts/html/master/webappapis.html#htmlmediaelement">HTMLMediaElement</a></code></dfn></li>
        <li><dfn><code><a href="https://www.w3.org/html/wg/drafts/html/master/webappapis.html#mediacontroller">MediaController</a></code></dfn></li>
        <li><dfn><code><a href="https://www.w3.org/html/wg/drafts/html/master/webappapis.html#texttrack">TextTrack</a></code></dfn></li>
        <li><dfn><code><a href="https://www.w3.org/html/wg/drafts/html/master/webappapis.html#texttrackkind">TextTrackKind</a></code></dfn></li>
      </ul>

      <p>
        The following interfaces are defined in [[!DOM]]:
      </p>
      <ul>
        <li><dfn><code><a href="https://www.w3.org/TR/dom/#event">Event</a></code></dfn></li>
        <li><dfn><code><a href="https://www.w3.org/TR/dom/#interface-eventtarget">EventTarget</a></code></dfn></li>
      </ul>

      <p>
        The <code><a href="https://dev.w3.org/html5/spec/webappapis.html#eventhandler">EventHandler</a></code> interface represents a callback used for <a>event handlers</a> as defined in [[!HTML5]].
      </p>

      <p>
        The <dfn>internal clock</dfn> is based on the precise, high-resolution, and monotonic clock defined in [[!HR-TIME]], with values representing <i>seconds</i>, not milliseconds. In essence, the <a>internal clock</a> is defined as <code>performance.now()/1000.0</code>. All time values refered to by the timing object specification are expressed in <i>seconds</i>. This includes timestamps in <a>state vectors</a> as well as <a>skew</a> estimates communicated from <a>timing provider objects</a> to <a>timing objects</a>.
      </p>

      <p>
        A <dfn>timing resource</dfn> is an object. This object essentially implements the abstraction of a <i>linear motion in real time</i>. For example, imagine a <i>point</i> moving along an <i>axis</i>. At a specific moment in time, this <i>point</i> has a specific <i>position</i> on the <i>axis</i>, a specific <i>velocity</i> and a specific <i>acceleration</i>. These three properties (all floating point values) define the state of the <a>timing resource</a> at that moment in time.
      </p>
      <p>
        A <a>timing resource</a> may either be an <dfn>internal timing resource</dfn>, an object under the control of a <a>user agent</a>, or an <dfn>external timing resource</dfn>, an object under the control of a <a>timing resource provider</a>. Both types exist locally in the user agent, but the <a>external timing resource</a> may be a proxy object for an <dfn data-lt="online timing resources">online timing resource</dfn>, i.e. an object hosted remotely by an online service.
      </p>
      <p class="note">
        A <a>user agent</a> may typically offer native implementations of <a>timing objects</a>, especially when the protocol needed is not available to Web applications. For instance, the clock synchronization mechanism defined in DVB for companion screens and streams [[DVB-CSS]] uses a UDP-based protocol. A <a>user agent</a> could perhaps expose a <code>DVBCSSTimingObject</code> interface to allow Web applications to connect to a companion screen that supports this protocol.
      </p>
      <p>
        This document provides interface definitions using the [[!WEBIDL]] standard.
      </p>
    </section>











    <!-- EXAMPLES -->



    <section class="informative">
      <h2>Examples</h2>
      <p>This section contains a few minimal code examples that show how a timing object may be used.</p>

      <section>
      <h3>Query</h3>
      <pre class="example highlight" title="Read the current position of a timing object">
      // Create timing object at position 2
      // (note velocity and acceleration default to 0)
      var to = new TimingObject({ position: 2.0 });

      // Read and report current value to the console
      // (renders "pos:2 vel:0, acc:0" in this example)
      var vector = to.query();
      console.log("pos:" + vector.position +
        " vel:" + vector.velocity +
        " acc:" + vector.acceleration);
      </pre>
      </section>

      <section>
      <h3>Update</h3>
      <pre class="example highlight" title="Play and pause buttons to control a timing object">
      // Pointers to "play" and "pause" buttons in the DOM
      var playbutton, pausebutton;

      // Start/Stop timing object when buttons are clicked
      var to = new TimingObject();
      playbutton.onclick = function () {
        to.update({ velocity: 1.0 });
      };
      pausebutton.onclick = function () {
        to.update({ velocity: 0.0 });
      };
      </pre>
      </section>

      <section>
      <h3>Polling</h3>
      <p>By querying the timing object repeatedly we can refresh time sensitive UI and demonstrate that the value of the timing object is changing predictably in time.</p>
      <pre class="example highlight" title="Poll and render position periodically">
      var elem; // DOM Element
      var to = new TimingObject();
      setInterval(function () {
        elem.innerHTML = to.query().position;
      }, 100);
      </pre>

      <p>Alternatively, use the built-in <i>timeupdate</i> event (fixed frequency).</p>
      <pre class="example highlight" title="Render position periodically based on timeupdate event">
      var elem; // DOM Element
      var to = new TimingObject();
      var to.addEventListener("timeupdate", function (e) {
        elem.innerHTML = to.query().position;
      });
      </pre>
      </section>

      <section>
      <h3>Update Event</h3>
      <p>Update operations cause abrupt changes to the timing object. Register a handler to be notified.</p>
      <pre class="example highlight" title="Report when a timing object stops moving">
      var elem; // DOM Element
      var to = new TimingObject();
      to.addEventListener("update", function (e) {
        var vector = to.query();
        if (vector.velocity === 0.0 &amp;&amp; vector.acceleration === 0.0) {
          elem.innerHTML = "I'm not moving!";
        } else {
          elem.innerHTML = "I'm moving!";
        }
      });

      // Make timing object move and then stop it
      to.update({ velocity: 5, acceleration: 1 });
      to.update({ velocity: 0, acceleration: 0 });
      </pre>
      </section>

      <section>
      <h3>Connect to a media element</h3>
      <p>
        A media element connected to a timing object will provide media playback precisely time-aligned with that timing object. In essence, the media element becomes a slave to the timing object. Pausing the timing object implies pausing the media element, etc.
      </p> 
      <pre class="example highlight" title="Use timing object to control a video">
      var video; // Pointer to a video element in the DOM
      var to = new TimingObject();
      video.timingsrc = to; // Video now directed by timing object

      // Start timing object (video seeks and starts by implication)
      to.update({ position: 5.0, velocity: 1.0 });
      </pre>
      </section>


      <section>
      <h3>Connect to a timing text track</h3>
      <p>A timing text track connected to a timing object will provide enter/exit events for timed data, precisely time-aligned with that timing object. In essence, the timing text track becomes a slave to the timing object. Pausing the timing object implies pausing the timing text track, etc. </p>
      <pre class="example highlight" title="Play simple timed data">
      var elem; // DOM element
      var to = new TimingObject();

      // Create timed data
      var track = new TimingTextTrack("metadata");
      var cue = new DataCue(12.783, 13.612, "dog bark");
      track.addCue(cue);
      cue.addEventListener("enter", function () {
        elem.innerHTML = "Dog is barking";
      });
      cue.addEventListener("exit", function () {
        elem.innerHTML = "Dog is silent";
      });
      track.timingsrc = to; // track directed by timing object
      to.update({ velocity: 1.0 }); // start playing timed data
      </pre>
      </section>

      <section>
      <h3>Connect to a timing provider</h3>
      <p>A <a>timing object</a> may take its input from a <a>timing provider object</a> provided by some third-party provider (or developed by the app developer). <a>Timing provider objects</a> will typically act as proxies to online timing resource, thus enabling cross-device synchronization.</p>
      <pre class="example highlight" title="Connect to a TimingProvider object">
      // TimingProvider object
      // (constructor and parameters are provider-specific)
      var tp;

      // Create timing object associated with timing provider source
      var to = new TimingObject(tp);
      var to.addEventListener("timeupdate", function (e) {
        var vector = to.query();
        console.log("pos:" + vector.position +
          " vel:" + vector.velocity +
          " acc:" + vector.acceleration);
      });
      </pre>
      </section>

    </section>


    <!-- TIMING OBJECT -->



    <section>
      <h2>Timing Object</h2>

      <p>
        A <dfn data-lt="timing object|timing objects">timing object</dfn> is an object that exposes a <a>timing resource</a> represented by a <a>state vector</a> to a Web application.
      </p>

      <p>
        A <a>timing object</a> can have a <dfn>timing provider source</dfn>, which is a <code><a href="#timing-provider-object">TimingProvider</a></code> object that encapsulates the logic needed to represent an <a>external timing resource</a>. The <a>timing provider source</a> is initialized once and for all when the <a>timing object</a> is created.
      </p>

      <p>
        If the <a>timing object</a> is associated with a <a>timing provider object</a>, the <a>timing object</a> has an <dfn data-lt="clock skew">internal clock skew</dfn>. This represents the current estimate of the skew between the <a>internal clock</a> and the clock employed by the <a>timing resource provider</a>. The <a data-lt="clock skew">internal clock skew</a> is provided by the <a>timing provider object</a>, and defined so that <var>clock<sub>timing provider</sub></var> === <var>clock<sub>user agent</sub></var> + <var>skew</var>, where <var>clock<sub>user agent</sub></var> is the <a>internal clock</a> of the <a>timing object</a>, expressed in seconds. <a data-lt="clock skew">internal clock skew</a> is also expressed in seconds. This equation is used by the <a>user agent</a> to convert timestamps between the timelines of the two clocks. The <a>user agent</a> must ensure monotonic behavior by, if necessary, applying skew changes gradually (see <a href="#calculate-skew-adjustment"></a>). 
      </p>

      <p>
        A <a>timing object</a> has an <dfn>internal vector</dfn> that represents the initial conditions of the current motion. The <a>internal vector</a> is used by the <code>query()</code> operation to calculate a snapshot <a>state vector</a> of the current motion. If the <a>timing object</a> is associated with a <a>timing provider object</a>, the <a>internal vector</a> is provided by the <a>timing resource provider</a> and therefore includes a timestamp value from the timeline of the <a>timing resource provider</a>.
      </p>

      <p>
        A <a>timing object</a> has a <dfn>state</dfn> property that describes the operational state of the <a>timing object</a>. If the <a>timing object</a> is associated with a <a>timing provider object</a>, the operational <a>state</a> will reflect the state of the <a>timing provider object</a>, and by implication the underlying communication link. 
      </p>

      <p>
        A <a>timing object</a> can have a <dfn>start position</dfn> and an <dfn>end position</dfn> that together define the <dfn>range</dfn> of positions for the <a>timing object</a>. Internally, the <a>timing object</a> must enforce this <a>range</a> restriction by updating its <a>internal vector</a> if a <a>range</a> violation occurs (at the correct moment). The <a>timing object</a> will maintain a <dfn>current range timeout</dfn> for this purpose, pointing to a scheduled timeout when set.
      </p>


      <p>A <a>timing object</a> implements the following interface:</p>

      <pre class="idl">
        [Exposed=Window]
        interface TimingObject : EventTarget {
          constructor(optional TimingStateVectorUpdate vector = {},
                      optional unrestricted double startPosition,
                      optional unrestricted double endPosition);
          constructor(TimingProvider provider);
          readonly    attribute TimingProvider timingProviderSource;
          readonly    attribute TimingObjectState readyState;
          readonly    attribute unrestricted double startPosition;
          readonly    attribute unrestricted double endPosition;
                      attribute EventHandler      onreadystatechange;
                      attribute EventHandler      onchange;
                      attribute EventHandler      ontimeupdate;
                      attribute EventHandler      onerror;
          TimingStateVector query ();
          Promise&lt;void&gt; update (optional TimingStateVectorUpdate newVector = {});
        };
      </pre>

      <div data-dfn-for="TimingObject" data-link-for="TimingObject">
        <p>
          The <dfn>startPosition</dfn> and <dfn>endPosition</dfn> attributes MUST respectively be set to the <a>start position</a> and <a>end position</a> that the <a>state vector</a> may take, if any, or <code>-Infinity</code> and <code>Infinity</code> otherwise.
        </p>
        <p>
          The <dfn>readyState</dfn> attribute MUST be set to the current state of the <a>timing object</a>. If the <a>timing object</a> represents an <a>internal timing resource</a>, this will typically always be <code>connecting</code> or <code>open</code>. The <a>readyState</a> attribute may take other values when the <a>timing object</a> represents an <a>external timing resource</a>.
        </p>
        <p>
          The <dfn>timingProviderSource</dfn> attribute MUST be set to the <a>timing provider source</a> of the <a>timing object</a>, if any, or null otherwise.
        </p>
      </div>

      <div class="issue" data-number="13"></div>
      <div class="issue" data-number="14"></div>

      <section>
        <h3>Create a new timing object</h3>
        <p>
          When the <code><a>TimingObject</a></code> constructor that takes an optional vector, a start position and an end position is invoked, the <a>user agent</a> MUST run the following steps:
        </p>
        <ol>
          <li>Let <var>timing</var> be a newly created <code><a>TimingObject</a></code>.</li>
          <li>Let <var>t</var> be a fresh timestamp read from the <a>internal clock</a>, defining the time of creation.
          <li>Let <var>vectorInit</var> be the four-tuple <code>(p, v, a, t)</code>, where <code>(p, v, a)</code> are from the constructors first argument, or <code>(0,0,0)</code> if no argument is provided.</li> 
          <li>Let <var>timing</var>'s <a>internal vector</a> be a newly constructed <code><a>TimingStateVector</a></code> that represents <var>vectorInit</var>.</li>
          <li>Let <var>timing</var>'s <a>timing provider source</a> be null.</li>
          <li>Let <var>timing</var>'s <a>start position</a> be the constructor's second argument or <code>-Infinity</code> if not given.</li>
          <li>Let <var>timing</var>'s <a>end position</a> be the constructor's third argument or <code>Infinity</code> if not given.</li>
          <li>If <var>timing</var>'s <a>range</a> does not <a>cover</a> the position of the <a>internal vector</a>:
            <ol>
              <li>Let <var>timing</var>'s <a>internal vector</a>'s position be <a>start position</a> or <a>end position</a>, whichever is closest</li>
              <li>Let <var>timing</var>'s <a>internal vector</a>'s velocity and acceleration be <code>0.0</code> if the direction of the motion would make the position leave the <a>range</a> immediately.</li>
              <li><a>Set the internal timeout</a> of <var>timing</var>.</li>
            </ol>
          </li>
          <li>Let <var>timing</var>'s <a>state</a> be <code>open</code>.</li>
          <li><a>Queue a task</a> to <a>fire a simple event</a> named <code>readystatechange</code> at <var>timing</var>.</li>
          <li>Return <var>timing</var>.</li>
        </ol>
 

        <p>
          When the <code><a>TimingObject</a></code> constructor that takes a <code><a>TimingProvider</a></code> is invoked, the <a>user agent</a> MUST run the following steps:
        </p>
        <ol>
          <li>Let <var>provider</var> be the constructor's argument.</li>
          <li>Let <var>timing</var> be a newly created <code><a>TimingObject</a></code> whose <a>timing provider source</a> is <var>provider</var>.</li>
          <li>Let <var>timing</var>'s <a>start position</a> be <var>provider</var>'s <code>startPosition</code> property.</li>
          <li>Let <var>timing</var>'s <a>end position</a> be <var>provider</var>'s <code>endPosition</code> property.</li>
          <li>Let <var>timing</var>'s <a>state</a> be <var>provider</var>'s <code>readyState</code> property.</li>
          <li>Let <var>timing</var>'s <a>internal vector</a> be <var>provider</var>'s <code>vector</code> property.</li>
          <li>Let <var>timing</var>'s <a data-lt="clock skew">internal skew</a> be <var>provider</var>'s <code>skew</code> property.</li>
          <li><a>Observe</a> <var>provider</var>.</li>
          <li>
            When an update to the <code>readyState</code> property is observed, run the following substeps:
            <ol>
              <li>If the transition from the current <a>state</a> of <var>timing</var> to the new value is in the list of <a>allowed state transitions</a>, let <var>timing</var>'s <a>state</a> be the new value. Otherwise, let <var>timing</var>'s <code>state</code> be <code>closed</code> and <a>stop observing</a> <var>provider</var>.</li>
              <li>If the <code>error</code> property of <var>provider</var> is not null, <a>queue a task</a> to <a>fire a simple event</a> named <code>error</code> at <var>timing</var>.</li>
              <li><a>Queue a task</a> to <a>fire a simple event</a> named <code>readystatechange</code> at <var>timing</var>.</li>
            </ol>
          </li>
          <li>
            When an update to the <code>vector</code> property is observed, run the following substeps:
            <ol>
              <li>Let <var>newVector</var> be the new value of <var>provider</var>'s <code>vector</code> property.</li>
              <li><a>Process vector change</a> with <var>newVector</var> as parameter.</li>
            </ol>
          </li>
          <li>
            When an update to the <code>skew</code> property is observed, run the following substeps:
            <ol>
              <li>Let <var>newSkew</var> be the new value of <var>provider</var>'s <code>skew</code> property.</li>
              <li><a>Process skew change</a> with <var>newSkew</var> as parameter.</li>
            </ol> 
          </li>
          <li>Return <var>timing</var>.</li>
        </ol>

        <p>
          When a <a>user agent</a> is required to <dfn>observe</dfn> an object and run specific steps when an update to a property is detected, it MUST start to monitor the changes made to that object in the background and run the given steps as soon as the requested change is observed.
        </p>
        <p>
          When a <a>user agent</a> is required to <dfn>stop observing</dfn> an object, it MUST stop any monitoring that was running on that object in the background.
        </p>
        <p class="issue">
          This <a data-lt="observe">observing</a> mechanism is meant to emulate the <code>Object.observe</code> method that is being proposed in EcmaScript 7 to simplify the <code><a>TimingProvider</a></code> interface and requirements set on a <a>timing resource provider</a>, as well as to work around the fact that <code><a>TimingProvider</a></code> cannot inherit <code><a>EventTarget</a></code>. The Multi-Device Timing Community Group welcomes feedback as to whether this approach is doable in practice.
        </p>
      </section>

      <section>
        <h3>Process a query operation</h3>

        <p>
          The <dfn data-dfn-for="TimingObject">query</dfn> method returns a snapshot derived from the evaluation of <a>internal vector</a> against the current timestamp of the <a>internal clock</a>. When the method is invoked on a <a>timing object</a> <var>timing</var>, the <a>user agent</a> MUST run the following steps:
        </p>
        <ol>
          <li>Let <var>timing</var> be that <code><a>TimingObject</a></code>.</li>
          <li>If the <a>state</a> of <var>timing</var> is not <code>open</code>, throw  new <code>InvalidStateError</code> and abort all further steps.</li>
          <li>Let <var>t<sub>u</sub></var> be the reading of the <a>internal clock</a>, defining the processing time of the operation.</li>
          <li>Let (<var>p<sub>int</sub></var>, <var>v<sub>int</sub></var>, <var>a<sub>int</sub></var>, <var>t<sub>int</sub></var>) represent the <a>internal vector</a> of <var>timing</var>.</li>
          <li>If the <a>timing provider source</a> of <var>timing</var> is null, let <var>d</var> be <code><var>t<sub>u</sub></var>-<var>t<sub>int</sub></var></code>.</li>
          
          <li>If the <a>timing provider source</a> of <var>timing</var> is not null, let <var>d</var> be <code><a>translate_u2p</a>(<var>t<sub>u</sub></var>)-<var>t<sub>int</sub></var></code>.</li>
          
          <li>Let <var>p</var> be <var>p<sub>int</sub></var> + <var>v<sub>int</sub></var> * <var>d</var> + 1/2 * <var>a<sub>int</sub></var> * <var>d</var><sup>2</sup></li>
          <li>Let <var>v</var> be <var>v<sub>int</sub></var> + <var>a<sub>int</sub></var> * <var>d</var></li>
          <li>Let <var>a</var> be <var>a<sub>int</sub></var></li>
          <li>Let <var>result</var> be newly created <code><a>TimingStateVector</a></code> from four-tuple (<var>p</var>, <var>v</var>, <var>a</var>, <var>t<sub>u</sub></var>)

          <li>Range violation is detected. If <var>timing</var>'s <a>range</a> does not <a>cover</a> <var>p</var>, run the following substeps:
            <ol>
              <li>Let <var>start</var> be <var>timing</var>'s <code>startPosition</code> property.</li>
              <li>Let <var>end</var> be <var>timing</var>'s <code>endPosition</code> property.</li>
              <li>Let <var>p<sub>modified</sub></var> be either <var>start</var> or <var>end</var>, whichever is closest to <var>p</var>.</li>
              <li>Let <var>vector</var> be newly created <code>TimingStateVectorUpdate</code> that from three-tuple (<var>p<sub>modified</sub></var>, 0, 0).</li>
              <li>Let <var>timing</var>'s <a>internal vector</a> be <var>vector</var>.</li>
              <li>Clear the <a>current range timeout</a> of <var>timing</var>.</li>
              <li><a>Queue a task</a> to <a>fire a simple event</a> named <code>change</code> at the <var>timing</var>.</li>
              <li>Let <var>result</var> be result from invoking <a data-link-for="TimingObject">query</a> method on <var>timing</var> (recursively).</li>
            </ol>
          </li>
          <li>Return <var>result</var>.</li>
        </ol>
      </section>



      <section>
        <h3>Process an update operation</h3>
        <p>
          The <dfn data-dfn-for="TimingObject">update</dfn> method sends a request for the <a>timing object</a> to update its current motion based on the provided <a>state vector</a>, or, if the <a>timing object</a> is associated with a <a>timing provider object</a>, the request is sent to an <a>external timing resource</a> via the <a>timing provider source</a>. In both cases, a <code>Promise</code> that the update was taken into account is returned. The method supports <code>null</code> or <code>undefined</code> values for the provided <a>state vector</a> attributes. This provides a simple mechanism for tying movements together. The idea is to allow one aspect of the movement to be updated while preserving the others. For instance, <code>{position:null, velocity:value, acceleration:null}</code> means <i>update the velocity to the given value while preserving the current position and acceleration</i>. If all attributes of the <a>state vector</a> are <code>null</code> or <code>undefined</code>, the method is a noop and returns immediately.
        </p>
        <p>
          When the <a data-link-for="TimingObject">update</a> method is invoked on a <a>timing object</a> <var>timing</var>, the <a>user agent</a> MUST run the following steps:
        </p>
        <ol>
          <li>Let <var>timing</var> be that <code><a>TimingObject</a></code>.</li>
          <li>If the <a>state</a> of <var>timing</var> is not <code>open</code>, return a new <code>Promise</code>, reject the promise with <code>InvalidStateError</code> and abort all further steps.</li>

          <li>Let <var>newVector</var> be the method's first parameter.</li>
          <li>If the <a>timing provider source</a> of <var>timing</var> is not null, run the following substeps, and abort the remaining steps:
            <ol>
              <li>Let <var>promise<sub>provider</sub></var> be the result of calling <code>update()</code> on the <a>timing provider source</a> object with <var>newVector</var> as parameter. If the call throws an exception, return a new <code>Promise</code>, reject the promise with the exception and abort all remaining steps. Similarly, if the call does not return a <code>Promise</code>, return a new <code>Promise</code>, reject the promise with a <code>TypeError</code> and abort all remaining steps.</li>
              <li>Return <var>promise<sub>provider</sub></var>.</li>
            </ol>
          </li>

          <li>Let <var>nowVector</var> be result from invoking <a data-link-for="TimingObject">query</a> method on <var>timing</var>.</li>
          <li>Let <var>intVector</var> be <var>timing</var>'s' <a>internal vector</a>.</li> 

          <li>Let (<var>p<sub>new</sub></var>, <var>v<sub>new</sub></var>, <var>a<sub>new</sub></var>) be the three-tuple represented by <var>newVector</var>.</li>
          <li>Let (<var>p<sub>now</sub></var>, <var>v<sub>now</sub></var>, <var>a<sub>now</sub></var>, <var>t<sub>now</sub></var>) be the four-tuple represented <var>nowVector</var>.</li>
          <li>Let (<var>p<sub>int</sub></var>, <var>v<sub>int</sub></var>, <var>a<sub>int</sub></var>, <var>t<sub>int</sub></var>) be the four-tuple represented <var>intVector</var>.</li>

          <li>Let <var>p</var> be <var>p<sub>new</sub></var>, or <var>p<sub>now</sub></var> if <var>p<sub>new</sub></var> is <code>null</code> or <code>undefined</code>.
          <li>Let <var>v</var> be <var>v<sub>new</sub></var>, or <var>v<sub>now</sub></var> if <var>v<sub>new</sub></var> is <code>null</code> or <code>undefined</code>.
          <li>Let <var>a</var> be <var>a<sub>new</sub></var>, or <var>a<sub>now</sub></var> if <var>a<sub>new</sub></var> is <code>null</code> or <code>undefined</code>.

          <li>Avoid range violation on update. Run the following substeps:
            <ol>
              <li>If <var>timing</var>'s <a>range</a> does not <a>cover</a> <var>p</var> throw a new <code>IllegalValueError</code> and abort any further steps.</li>
              <li>Let <var>start</var> be <var>timing</var>'s <code>startPosition</code> property.</li>
              <li>If <code><var>p</var> === start &amp;&amp; (<var>v</var> &lt; 0|| (<var>v</var> === 0 &amp;&amp; <var>a</var> &lt; 0))</code> throw a new <code>IllegalValueError</code> and abort any further steps.</li>
              <li>Let <var>end</var> be <var>timing</var>'s <code>endPosition</code> property.</li>
              <li>If <code><var>p</var> === end &amp;&amp; (<var>v</var> > 0 || (<var>v</var> === 0 &amp;&amp; <var>a</var> > 0))</code> throw a new <code>IllegalValueError</code> and abort any further steps.</li>
            </ol>
          </li>
 
          <li>Let <var>vector</var> be a newly created <code><a>TimingStateVector</a></code> that represents the four-tuple (<var>p</var>, <var>v</var>, <var>a</var>, <var>t<sub>now</sub></var>).</li>
          <li>Set the <a>internal vector</a> of <var>timing</var> to <var>vector</var>.</li>
          <li><a data-lt="set the internal timeout">Set the internal timeout</a> of <var>timing</var>.</li>
          <li><a>Queue a task</a> to <a>fire a simple event</a> named <code>change</code> at <var>timing</var>.</li>
          <li>Resolve <var>promise</var>.</li>
        </ol>
      </section>

      <section>
        <h3>Set the internal timeout</h3>
        <p>
          If <a>timing object</a>'s properties <code>startPosition</code> and <code>endPosition</code> are specified, e.g. <code>[0,123]</code>, the timing object must schedule a future <code>update</code> operation on itself, to ensure that the <a>range</a> is not violated.
        <p>
        <p>
          When the <a>user agent</a> is required to <dfn>set the internal timeout</dfn> of a <a>timing object</a>, it must run the following steps:
        </p>
        <ol>
          <li>Let <var>timing</var> be that <code><a>TimingObject</a></code>.</li>
          <li>If <var>timing</var>'s <a>current range timeout</a> is not null, cancel the timeout and let <var>timing</var>'s <a>current range timeout</a> be null.</li>
          <li>Let <var>startPos</var> be <var>timing</var>'s <code>startPosition</code>.</li>
          <li>Let <var>endPos</var> be <var>timing</var>'s <code>endPosition</code>.</li>
          <li>Given the current motion, let <var>endpoint</var> be the first of <var>startPos</var> or <var>endPos</var> to be violated first, if any, and let <var>t</var> be the time when this will occur according to the <a>internal clock</a>.</li>
          <li>If <var>endpoint</var> is null or Infinity or -Infinity, abort all further steps.</li>
          <li>Let <var>vector</var> be the <code>TimingStateVector</code> represented by four-tuple (<var>endpoint</var>, 0, 0, t).</li>
          <li>Let <var>timing</var>'s <a>current range timeout</a> be a newly created timeout to execute an <code>update</code> operation on <var>timing</var> with <var>vector</var> as parameter, at the moment when the <a>internal clock</a> reaches <var>t</var>.</li> 
        </ol>
      </section>

      <section>
        <h3>Cover a position</h3>
        <p>
          When the <a>user agent</a> is required to evaluate whether a <a>range</a> composed of possibly infinite lower and upper bounds <dfn data-lt="cover">covers</dfn> a provided value, the <a>user agent</a> MUST run the following steps:
        </p>
        <ol data-link-for="TimingObject">
          <li>Let <var>value</var> be the position to evaluate.</li>
          <li>If <var>value</var> is smaller than the <a>range</a>'s lower bound, return <code>false</code>, and abort these steps.</li>
          <li>If <var>value</var> is greater than the <a>range</a>'s upper bound, return <code>false</code>, and abort these steps.</li>
          <li>Return true.</li>
        </ol>
      </section>

      <section>
        <h3>Process Vector Change</h3>
        <p>
          When the <a>user agent</a> is required to <dfn>process vector change</dfn> on a <a>timing object</a>, it MUST run the following steps:
        </p>
        <ol>
          <li>Let <var>timing</var> be that <code><a>TimingObject</a></code>.</li>
          <li>Let <var>newVector</var> be the new vector.</li>
          <li>Let <var>timing</var>'s <a>internal vector</a> be <var>newVector</var>.</li>
          <li><a data-lt="set the internal timeout">Set the internal timeout</a> of <var>timing</var>.</li>
          <li><a>Queue a task</a> to <a>fire a simple event</a> named <code>change</code> at <var>timing</var>.</li>
        </ol>
      </section>

      <section>
        <h3>Process Skew Change</h3>
        <p>
          When the <a>user agent</a> is required to <dfn>process skew change</dfn> on a <a>timing object</a>, it MUST run the following steps:
        </p>
        <ol>
          <li>Let <var>timing</var> be that <code><a>TimingObject</a></code>.</li>
          <li>Let <var>newSkew</var> be the new skew.</li>
          <li>Let <var>oldSkew</var> be <var>timing</var>'s <a>internal clock skew</a>.</li>
          <li>Let <var>timing</var>'s <a>internal clock skew</a> be <var>newSkew</var>.</li>
          <li>Update variables used by <code><a data-lt="calculate skew adjustment">calculate_skew_adjustment()</a></code> based on <var>newSkew</var> and <var>oldSkew</var></li>
        </ol>
      </section>
     
      <section>
        <h3>Translate timestamp from user agent to timing resource provider timeline</h3>
        <p>
          <dfn data-lt="translate_u2p"><code><var>t<sub>p</sub></var> = translate_u2p(<var>t<sub>u</sub></var>)</code></dfn> translates a timestamp from the timeline of the <a>user agent</a> (u) to the timeline of the <a>timing resource provider</a> (p).
        </p>
        <p>
          When the <a>translate_u2p</a> method is invoked, the <a>user agent</a> MUST run the following steps:
        </p>
        <ol>
          <li>Let <var>t<sub>u</sub></var> be the first parameter.</li>
          <li>Let <var>skew</var> be the value of <a>timing provider source</a>'s <code>skew</code> property.</li>
          <li>Let <var>effectiveskew</var> be the result of <var>skew</var> - <a data-lt="calculate skew adjustment">calculate_skew_adjustment()</a></li>
          <li>Return <var>t<sub>u</sub></var> + <var>effectiveskew</var>.</li>
        </ol>
      </section>


      <section>
        <h3>Translate timestamp from timing resource provider to user agent timeline</h3>
        <p>
          <dfn data-lt="translate_p2u"><code><var>t<sub>u</sub></var> = translate_p2u(<var>t<sub>p</sub></var>)</code></dfn> translates a timestamp from the timeline of the <a>timing resource provider</a> (p) to the timeline of the <a>user agent</a> (u).
        </p>
        <p>
          When the <a>translate_p2u</a> method is invoked, the <a>user agent</a> MUST run the following steps:
        </p>
        <ol>
          <li>Let <var>t<sub>p</sub></var> be the first parameter.</li>
          <li>Let <var>skew</var> be the value of <a>timing provider source</a>'s <code>skew</code> property.</li>
          <li>Let <var>effectiveskew</var> be the result of <var>skew</var> - <a data-lt="calculate skew adjustment">calculate_skew_adjustment()</a></li>
          <li>Return <var>t<sub>p</sub></var> - <var>effectiveskew</var>.</li>
        </ol>
      </section>


      <section>
        <h3>Calculate skew adjustment</h3>
        <p>
          A <a>user agent</a> MUST implement skew changes reported by a <a>timing provider object</a> gradually, in order to ensure the monotonicity of <code>timestamp</code> values reported by the <a data-link-for="TimingObject">query</a> method of a <a>timing object</a>. For example, if the skew estimate increases by 2 ms at one point, one might want to apply this change at a certain rate, for instance 1 ms change per 10ms, so that, after 20ms, the 2ms change is fully applied. To achieve this, the <a>user agent</a> may update the <a>internal clock skew</a> immediately on skew change, and then define a linear adjustment function that is subtracted from the skew. In the above example the function will subtract the full 2ms initially, 1ms after 10ms, and then 0ms after 20ms. New skew changes must be integrated into the adjustment function.
        </p>
        <p>
          The internal <dfn data-lt="calculate_skew_adjustment"><code>calculate_skew_adjustment()</code></dfn> method implements this logic. If the method always returns <code>0</code>, skew changes are fully applied as soon as they are received (i.e. not gradually applied). The logic of this method involves some bookkeeping, i.e. how much of the skew changed is already applied at a given point, and how much remains. New skew changes require this information to be re-evaluated. Note that this function is only invoked as part of a query operation. The actual logic of this method is left unspecified.
        </p>
        <p class="note">
          In practice, it is not clear that monotonic behavior at the millisecond scale is required by any of the existing use cases. Monotonic behavior is still included as requirement on the assumption that it may enable future use cases, and that is does not add much complexity. 
        </p>
      </section>


      <section>
        <h3>Connection states</h3>
        <p>
          The connection with the <a>timing resource</a> that the <a>timing object</a> represents may take the following states:
        </p>
        <pre class="idl">
          enum TimingObjectState {
            "connecting",
            "open",
            "closing",
            "closed"
          };
        </pre>
        <dl data-dfn-for="TimingObjectState">
          <dt><dfn>connecting</dfn></dt>
          <dd>The <a>timing object</a> is attempting to establish a connection with the <a>timing resource</a> it represents. This is the initial state when a new <code><a>TimingObject</a></code> is created. This state is also used when a <code><a>TimingProvider</a></code> object is associated with the <code><a>TimingObject</a></code>.</dd>

          <dt><dfn>open</dfn></dt>
          <dd>The connection with the <a>timing resource</a> is established and communication is possible.</dd>

          <dt><dfn>closing</dfn></dt>
          <dd>The procedure to close down the connection with the <a>timing resource</a> has started.</dd>

          <dt><dfn>closed</dfn></dt>
          <dd>The connection with the <a>timing resource</a> has been closed or could not be established.</dd>
        </dl>

        <p>
          The <dfn>allowed state transitions</dfn> are:
        </p>
        <ul>
          <li>from <code>connecting</code> to any of the other states;</li>
          <li>from <code>open</code> to <code>closing</code> and <code>closed</code>;</li>
          <li>from <code>closing</code> to <code>closed</code>.</li>
        </ul>
      </section>

      <section>
        <h3>Event handlers</h3>

        <p>The following are the <a>event handlers</a> (and their corresponding <a>event handler event types</a>) that MUST be supported as attributes by a <a>TimingObject</a> object. All events use the <a>Event</a> interface.</p>

        <table data-dfn-for="TimingObject">
          <thead>
            <tr>
              <th>Event handler</th>
              <th>Event handler event type</th>
              <th>Fired</th>
            </tr>
          </thead>
          <tbody>
 
            <tr>
              <td><dfn><code>onchange</code></dfn></td>
              <td><dfn><code>change</code></dfn></td>
              <td>The <a>internal vector</a> is changed. Fired after the <code>update()</code> method has returned, or when an update is received from the <a>external timing resource</a>.</td>
            </tr>
            <tr>
              <td><dfn><code>onreadystatechange</code></dfn></td>
              <td><dfn><code>readystatechange</code></dfn></td>
              <td>The <code>readyState</code> attribute changed.<br/></td>
            </tr>
            <tr>
              <td><dfn><code>ontimeupdate</code></dfn></td>
              <td><dfn><code>timeupdate</code></dfn></td>
              <td>Fires periodically with fixed frequency 5Hz, except when timing object is paused. This is intended as a shorthand alternative for setting up a polling-loop with setInterval, or as an emulation of the pulse-based timing model that programmers are currently used to.</td>
            </tr>
            <tr>
              <td><dfn><code>onerror</code></dfn></td>
              <td><dfn><code>error</code></dfn></td>
              <td>Fired when an operation on the <a>timing object</a> cannot complete for some reason, (e.g. because of a loss of connection with the <a>timing resource</a>).</td>
            </tr>
          </tbody>
        </table>
      </section>
    </section>







    <!-- TimingProvider -->

    <section>

      <h3>Timing Provider Object</h3>
      <p>
        A <dfn data-lt="timing provider object|timing provider objects">timing provider object</dfn> is an object exposed by a <a>timing resource provider</a> that encapsulates the logic necessary to associate a <a>timing object</a> with an <a>external timing resource</a>.
      </p>
      <p>
        The concept is introduced in order to leave space open for innovation among online timing providers. The purpose is to decouple the <a>user agent</a> from any particular <a>timing resource provider</a>: third-parties may provide different implementations of <a>timing provider objects</a> in JavaScript, to which <a>timing objects</a> may be connected. In particular, this means that the protocols and logic used to identify, create or destroy an <a>external timing resource</a>, synchronize clocks and propagate <a>state vectors</a> to connected user agents, are up to the <a>timing resource provider</a>. Similarly, a <a>timing resource provider</a> may require Web applications or users to authenticate themselves before they grant them access to a particular <a>timing resource</a>.
      </p>
      <p>
        In practice, a Web application willing to use a particular <a>timing resource provider</a> needs to load the corresponding JavaScript library provided by this <a>timing resource provider</a>, create a <a>timing provider object</a> and pass that object to the <a>timing object</a> constructor.
      </p>
      <p>
        The <a>TimingProvider</a> interface allows the <a>timing object</a> to exercise control over the <a>timing provider object</a>, as well as be notified of state changes as soon as they occur, in particular <a href="#state-vector-synchronization">state vectors</a> and <a href="#clock-synchronization">clock skew estimates</a> are exchanged across this interface.</p>
      <p>
        The <dfn>skew</dfn> specifies how timestamps may be translated between the timeline of the <a>internal clock</a> and that used by the <a>timing resource provider</a>. In the case of <a>online timing resources</a>, the <a>skew</a> is a floating estimate (due to variance in network latency and relative clock drift over time). The <code>query</code> operation on the <a>timing object</a> should always be resolved based on a fresh <a>skew</a> estimate received from the <a>timing provider object</a>. <a>Skew</a> is expressed in <i>seconds</i> and defined by the following equation (where <var>clock<sub>user agent</sub></var> is the <a>internal clock</a>): 
      </p>
      <p>
        <var>clock<sub>timing provider</sub></var> === <var>clock<sub>user agent</sub></var> + <var>skew</var>
      </p>
      <p>
        A <a>timing provider object</a> implements the following interface:
      </p>

      <pre class="idl">
        [Exposed=Window]
        interface TimingProvider {
          readonly    attribute TimingStateVector vector;
          readonly    attribute unrestricted double startPosition;
          readonly    attribute unrestricted double endPosition;
          readonly    attribute DOMString         readyState;
          readonly    attribute unrestricted double skew;
          Promise&lt;void&gt; update (optional TimingStateVectorUpdate newVector = {});
        };
      </pre>

      <div data-dfn-for="TimingProvider">
        <p>
          The <dfn>vector</dfn> attribute MUST be set to the <a>state vector</a> that represents the initial conditions of the current motion.
        </p>
        <p>
          The <dfn>startPosition</dfn> attribute MUST be set to the lower bound that constrains the position of the <a>state vector</a>, if any.
        </p>
        <p>
          The <dfn>endPosition</dfn> attribute MUST be set to the upper bound that constrains the position of the <a>state vector</a>, if any.
        </p>
        <p>
          The <dfn>readyState</dfn> attribute MUST be set to the current state of the connection with the <a>timing resource</a>.
        </p>
        <p>
          The <dfn>skew</dfn> attribute MUST be set to the current estimate of the skew.
        </p>
      </div>

      <div class="issue" data-number="10"></div>

      <section>
        <h3>Process an update operation</h3>
        <p>
          The <dfn data-dfn-for="TimingProvider">update</dfn> method sends a request to the <a>timing resource</a> to have it update the <a>external timing resource</a>, based on the provided <a>state vector</a>, and returns a <code>Promise</code> that the update was processed by the <a>timing resource provider</a> (see the <a data-link-for="TimingObject">update</a> method of <a>TimingObject</a> objects for more details). When the method is invoked on a <a>timing provider object</a> <var>provider</var>, the <a>timing resource provider</a> MUST run the following steps:
        </p>
        <ol>
          <li>Let <var>promise</var> be a new <code>Promise</code>.</li>
          <li>Return <var>promise</var> and run the following steps in parallel.</li>
          <li>Run whatever logic is necessary to pass the update request to the <a>external timing resource</a> that <var>provider</var> represents.</li>
          <li>If this logic succeeds, resolve <var>promise</var>. Otherwise reject <var>promise</var> with an error.</li>
        </ol>
      </section>

      <section>
        <h3>Report new conditions of the current motion</h3>
        <p>
          When the <a>timing resource provider</a> needs to report an update to the <a>state vector</a> (position, velocity or acceleration) of the <a>external timing resource</a> that a <code><a>TimingProvider</a></code> object encapsulates, it MUST set its <a data-link-for="TimingProvider">vector</a> property to a new <code><a>TimingStateVector</a></code> that represents the new conditions.
        </p>
      </section>

      <section>
        <h3>Report a state change</h3>
        <p>
          When the <a>timing resource provider</a> needs to report a change of connection state with the <a>external timing resource</a> that a <code><a>TimingProvider</a></code> object encapsulates, it MUST set its <a data-link-for="TimingProvider">readyState</a> property to the new value.
        </p>
      </section>

       <section>
        <h3>Report a skew change</h3>
        <p>
          When the <a>timing resource provider</a> needs to report a change of the skew estimate with the <a>external timing resource</a> that a <code><a>TimingProvider</a></code> object encapsulates, it MUST set its <a data-link-for="TimingProvider">skew</a> property to the new value.
        </p>
      </section>

      <section>
        <h3>Report an error</h3>
        <p data-link-for="TimingProvider">
          When the <a>timing resource provider</a> needs to report an unrecoverable error for a <code><a>TimingProvider</a></code> object, it MUST set its <a>error</a> property to the error and set its <a>readyState</a> property to <code>closed</code>.
        </p>
        <p class="note">
          This will effectively make any <code><a>TimingObject</a></code> object that has this <code><a>TimingProvider</a></code> object as <a>timing provider source</a> enter a final <code>closed</code> state.
        </p>
      </section>
    </section>







    <!-- TimingStateVector -->



    <section>
      <h2>State Vector</h2>

      <p>
        A <dfn data-lt="state vector|state vectors">state vector</dfn> represents the classical four-tuple <code>(position, velocity, acceleration, timestamp)</code> associated with the mathematical description of linear motion under constant acceleration. A <a>state vector</a> is used to represent the motion of a <a>timing resource</a>.
      </p>
      <p>
        In particular, the <a>internal vector</a> of a <a>timing object</a> is a <a>state vector</a>, the <code>query()</code> operation returns a <a>state vector</a> and the <code>update()</code> operation takes a <a>state vector</a> as parameter.
      </p>

      <p>A <a>State vector</a> implements the following interface:</p>

      <pre class="idl">
        dictionary TimingStateVectorUpdate {
          double position;
          double velocity;
          double acceleration;
        };

        dictionary TimingStateVectorInit : TimingStateVectorUpdate {
          double timestamp;
        };

        [Exposed=Window]
        interface TimingStateVector {
          constructor(optional TimingStateVectorInit vectorDict = {});
          readonly    attribute double position;
          readonly    attribute double velocity;
          readonly    attribute double acceleration;
          readonly    attribute double timestamp;
        };
      </pre>

      <div data-dfn-for="TimingStateVector" data-link-for="TimingStateVector">
        <p>
          The <dfn>position</dfn> attribute MUST be set to the position of the <a>state vector</a> on its unidimensional axis. The position unit is usage specific. The position may for example represent a point in time in seconds, a height in meters, a slide number in a slide show or something else entirely.
        </p>

        <p>
          The <dfn>velocity</dfn> attribute MUST be set to the velocity of the <a>state vector</a> on its unidimensional axis. The velocity represents the rate of change of the position, measured in position units per second.
        </p>

        <p>
          The <dfn>acceleration</dfn> attribute MUST be set to the acceleration of the <a>state vector</a> on its unidimensional axis. The acceleration represents the rate of change of the velocity, measured in position units per second squared.
        </p>

        <p>
          The <dfn>timestamp</dfn> attribute MUST be set to the moment in time when <a>position</a>, <a>velocity</a> and <a>acceleration</a> were|are|will be valid. The <a>timestamp</a> is from the timeline of the user agent defined by the <a>internal clock</a>, represented in seconds.
        </p>
      </div>

      <section>
        <h3>Create a new state vector</h3>
        <p>
          The <code>TimingStateVector</code> constructor is only intended to be used by the <a>timing resource provider</a> to set the <a data-link-for="TimingProvider">vector</a> attribute of a <a>TimingProvider</a> object.
        </p>
        <p>
          When the <code>TimingStateVector</code> constructor is called, the <a>user agent</a> MUST run the following steps:
        </p>
        <ol>
          <li>Let <var>vector</var> be a newly created <code><a>TimingStateVector</a></code>.</li>
          <li>Let (<var>p<sub>init</sub></var>, <var>v<sub>init</sub></var>, <var>a<sub>init</sub></var>, <var>t<sub>init</sub></var>) be the four-tuple represented by the constructor's first argument.</li>
          <li>Initialize <var>vector</var> so that it represents the four-tuple (<var>p<sub>init</sub></var>, <var>v<sub>init</sub></var>, <var>a<sub>init</sub></var>, <var>t<sub>init</sub></var>).</li>
          <li>Return <var>vector</var>.</li>
        </ol>
      </section>
    </section>




    <!-- MEDIA ELEMENTS -->
    <section>
      <h3><a>Media elements</a> and the <a>timing object</a></h3>
      <p>
        This section specifies an extension of <a>media elements</a> that allows them to use a <a>timing object</a> as a timing source.
      </p>

      <p class="note">
        If this specification progresses along the standardisation track, this section should be merged in a future version of [[!HTML5]].
      </p>

      <section class="informative">
        <h3>Introduction</h3>

        <p>
          The essential function of the <a>media element</a> is to provide playback of video and audio data. Playback is typically controlled by end-user interaction (e.g. play, pause, seekTo) as well as the availability of data (e.g. live streaming, buffering). In particular, if the buffer underflows during playback, playback is halted until data becomes available. We call this the <dfn>default playback mode</dfn>.
        </p>
        <p> 
          This section specifies <dfn>timed playback mode</dfn> as an alternative mode of operation for the <a>media element</a>. <a>Timed playback mode</a> implies that media playback is directed exclusively by an external <a>timing object</a>. The goal is to allow presentation of video and audio frames at the correct time (millisecond scale), relative to a timing object. In other words, in <a>timed playback mode</a> the function of the <a>media element</a> is to time-align its internal media player with a <a>timing object</a>. This way, <a>media elements</a> may take part in precisely coordinated multi-media presentations, both in single-device and multi-device scenarios. In particular, as errors in time-alignment should be well below 10 ms, use-cases such as echo-less Web radio (multiple devices in a room), multi-track music (on multiple devices) or synchronization with musical instruments should be supported.
        </p>
        <p>
          <a>Timed playback mode</a> and <a>default playback mode</a> are different in a few important respects:
        </p>
        <p>
          In <a>timed playback mode</a> there is no obligation to present all the media content. If the <a>timing object</a> starts playback before the <a>media element</a> is ready, then a small segment of media will simply not be presented. The <a>media element</a> must always focus on time-aligning its presentation with the <a>timing object</a>. This is equally true on load, after <a>timing object</a> change events, or in the event of missing data. If correct data is not available at any given point in time, the <a>media element</a> simply defaults to presenting a black screen, perhaps decorated with graphics illustrating the advancing offset of the <a>timing object</a> as well as the appropriate error message.
        </p>
        <p>
          The <a>media element</a> never halts the <a>timing object</a> in order to wait for data or other internal processing. Instead, end-users may choose to pause the presentation manually, or navigate back to see missing segments. Crucially, media controls (e.g. interactive buttons and progress bar) associated with the <a>media element</a> must be applied exclusively to the <a>timing object</a>. (The internal media player of the <a>media element</a> will be affected indirectly as a response to change events emitted by the <a>timing object</a>). This way, manually pausing a <a>media element</a> for buffering affects not only the <a>media element</a> but any other media component connected to the same <a>timing object</a>.
        </p>
        <p>
          To achieve precisely time-aligned playback, a <a>media element</a> must continuously monitor and adjust its internal media player. Even if the internal media player is perfectly time-aligned with the <a>timing object</a> at one point in time, media players may slowly drift away from the <a>timing object</a> over time. To counter this, the <a>media element</a> must monitor their time-alignment periodically, and adjust as the error grows too large. Using variable playback rate internally is an effective way of implementing adjustments gradually and precisely.
        </p>
        <p>
          <a data-lt="media elements">Media elements</a> take direction from a <a>timing object</a>, but playback capabilities are likely limited when it comes to high velocities, backwards playback or acceleration (supported by the <a>timing object</a>). Still, <a>media elements</a> must accept any state that the <a>timing object</a> supports, so throwing exceptions in these circumstances is not acceptable. Instead, <a>media elements</a> are free to fall back to black screen or graphical illustrations whenever the <a>timing object</a> specifies motions that are not supported by the internal media player.
        </p>

      </section>


      <section>
        <h3>Procedure: Set the current <a>timing object</a> for <a>media element</a>.</h3>
        <p>
          From the perspective of a <a>media element</a>, a <code><a>TimingObject</a></code> plays a role similar to a <code><a>MediaController</a></code>.
        </p>
        <p>
          A <a>media element</a> in <a>timed playback mode</a> has a <dfn>current timing source</dfn> which is a <code><a>TimingObject</a></code>. The <a>timing object</a> imposes the media clock that the <a>media element</a> uses.
        </p>

        <pre class="idl">
          partial interface HTMLMediaElement {
            attribute TimingObject timingsrc;
          };
        </pre>

        <p>
          The <code>timingsrc</code> attribute on a <a>media element</a> MUST, on getting, return the <a>current timing source</a>, if any, or null otherwise. On setting, the <a>user agent</a> MUST <a>set the current timing object for the media element</a>.
        </p>
     
        <p>
          When the <a>user agent</a> is to <dfn>set the current timing object for the media element</dfn>, it MUST run the following steps:
        </p>
        <ol>
          <li>Let <var>m</var> be the <a>media element</a> in question.</li>
          <li>Let <var>old controller</var> be <var>m</var>'s <a>current media controller</a>, it if currently has one, and null otherwise.</li>
          <li>Let <var>m</var> have no <a>current media controller</a>, if it currently has one.</li>
          <li>Remove the element's <code>mediagroup</code> content attribute, if any.</li>
          <li>Let <var>m</var> have no <a>current timing source</a>, it if currently has one.</li>
          <li>If the provided timing object is null, then jump to the <i>update controller</i> step below.</li>
          <li>Let <var>m</var>'s <a>current timing source</a> be the providedtiming object.</li>
          <li>Let <var>new timing</var> be <var>m</var>'s <a>current timing source</a>.</li>
          <li><a>check error in time-alignment</a>.</li>
          <li><i>Update controller</i>: If <var>old controller</var> is not null and still has one or more <a>slaved media elements</a>, then <a>report the controller state</a> for <var>old controller</var>.</li>
        </ol>

        <p>
          When a <a>media element</a> has a <a>current timing source</a>, its <code>currentTime</code> and <code>playbackRate</code> properties reflect the current state of the internal media player, not the <a>timing object</a>. This implies backwards compatibility for applications that uses the <a>media element</a> as timing source. Note that if the velocity of the <a>timing object</a> is 1.0, the <a>effective playback rate</a> of the <a>media element</a> might be slightly less or slightly larger than 1.0. An internal playback rate of 1.0 generally does NOT imply that playback offset advances with the exact speed of the system clock. In addition, <a>media elements</a> may adjust for error in time-alignment gradually by adjusting their internal playback rate every now and then. 
        </p>
      </section>

      <section>
        <h3>Procedure: Set the current media controller for <a>media element</a></h3>
        <p>
          The procedures defined in [[!HTML5]] that update the <a>current media controller</a> should be updated to include the following step before the <a>current media controller</a> is set:
        </p>
        <ol>
          <li>Let <var>m</var> have no <a>current timing source</a>, if it currently has one.</li>
        </ol>
      </section>

      <section>
        <h3>Procedure: Set the current position for <a>media element</a></h3>
        <p>
          The procedure defined in [[!HTML5]] that prevents setting <code>currentTime</code> when the <a>media element</a> has a <a>current media controller</a> should be updated to also prevent setting the attribute when the <a>media element</a> has a <a>current timing source</a>.
        </p>
        <p class="issue">
          An alternative to preventing the setting of <code>currentTime</code> would be to map such a request onto the <a>current timing source</a>.
          Following this approach, other media control commands such as <code>play</code> and <code>pause</code> could be mapped similarly.
        </p>
        <p class="note">
          The <code>playbackRate</code> attribute has no effect when the <a>media element</a> has a <a>current timing source</a>.
          Note also that <code>playbackRate</code> attribute does not trivially map to the current definition of a <a>timing object</a>. This is because <code>playbackRate</code> is effectively a persistent wish for a specific playbackRate, rather than the actual playbackRate at any time. If needed, the <a>timing object</a> may easily be extended with this functionality by application code.
        </p>
      </section>
      
      <section>
        <h3>Procedure: Check error in time-alignment for <a>media element</a></h3>
        <p>
          The user agent must <dfn>check error in time-alignment</dfn> between <a>timing object</a> and the internal player of the <a>media element</a>, and then make steps to adapt if error are too big. Checking the error involves the following steps:
        </p>
        <ol>
          <li>Let <var>m</var> be that <a>media element</a>.</li>
          <li>Let <var>timing</var> be that timing source.</li>
          <li>Let <var>max</var> be the maximum error that is tolerated.</li>       
          <li>Let <var>ideal</var> be the result of <code>timing.query().position</code>.</li>
          <li>Let <var>actual</var> be the currentTime of the internal media player.</li>
          <li>Let <var>error</var> be (<var>ideal</var> - <var>actual</var>).</li>
          <li>If (<var>error</var> &gt; <var>max</var>) start adjust time-alignment with given <var>error</var></li>.
        </ol>
      </section>

   
      <section>
        <h3>Procedure: Time-align <a>media element</a> with <a>timing object</a></h3>
        <p>
          Below is a rough explanation of how time-alignment may be adjusted. Details are left unspecified. However, a reference implementation of time-alignment, MediaSync [[MEDIASYNC]], is provided by the Multi-device Timing Community Group. This is a pure JavaScript implementation where time-alignment is implemented using the public API of the <a>media element</a>. This demonstrates that time-alignment at the millisecond scale is achievable, even without access to the internals of the <a>media element</a>. The assumption is that time-alignment may be even more precise and effective if supported by <a>media elements</a> internally.     
        </p>
        <p>
          If the error in time-alignment is very large (e.g. after a <a>timing object</a> update event) adjustments may require one or multiple <code>seekTo(X)</code> operations on the internal media player. The expected time-consumption of seekTo() operations should likely be taken into consideration when calculating <code>X</code>. If the internal media player (media format) supports variable playbackRate, this may be an effective way of implementing smaller adjustments gradually and more precisely. In both cases, adjusting the time-alignment is likely a multi-step process that goes on until the <var>error</var> is acceptible or cannot be further reduced.  
        </p>
      </section>
    

    </section>



    <!-- SEQUENCING -->

    <section>

      <h3>Timed data and the timing object</h3>

      <p>
        This section specifies how a timing object may be used to direct timed presentation/execution of timed data.
      </p>

      <section class="informative">
        <h3>Introduction</h3>

        <p>
          In this document, the process of translating a timed script or timed data into timed execution is broadly referred to as <dfn data-lt="sequencer">sequencing</dfn>. <a>Sequencing</a> functionality is already provided by existing media frameworks, for example <a>text tracks</a> integrated with <a>media elements</a>, audio sample scheduling within the Web Audio API [[WEBAUDIO]], or timegraph traversal within SMIL Timing [[SMIL3]]. 
        </p>
        <p>
          Similarly, the ability to connect <a>sequencing</a> logic (e.g. a <a>text track</a>) to a <a>timing object</a> would be very useful. It would allow timed data to be time-aligned (synchronized) with any other timed component, provided only that they are directed by the same <a>timing object</a>. Crucially, this would also be true in the multi-device scenario, as distributed <a>timing objects</a> may connect to and be directed by the same online timing source. Below we list important design goals for a general purpose <a>sequencing</a> mechanism for the Web.  
        </p>
        <ul>
          <li><b>Data-independency.</b> The <a>sequencing</a> mechanism should be implemented without reference to any specific data format. This way, timing support for a wide range of data formats can be provided, including application-specific data formats.</li>
          <li><b>UI-independency.</b> The <a>sequencing</a> mechanism should not be bundled with any predefined UI elements or UI frameworks. This ensures that programmers are free to exploit it for any purpose, including purposes that require custom UI solutions or no UI at all. General purpose UI components for timed presentation may still be developed and shared independently.</li>
          <li><b>Precise timing.</b> The <a>sequencing</a> mechanism should be based on a precise timeout mechanism (e.g. setTimeout) for enter/exit events to be emitted with high precision, ideally correct down to a single millisecond.</li>
          <li><b>Expressive controls.</b> The <a>sequencing</a> mechanism should support any motion supported by the <a>timing object</a>, including fast forward, slow motion, backwards playback, immediate jumps or acceleration. This way, the <a>sequencing</a> mechanism may support a variety of media control primitives, appropriate for a wide range of media applications.</li>
          <li><b>Dynamic data.</b> The <a>sequencing</a> mechanism should allow modifications of timed data to safely occur at any time, with immediate and consistent effects, and without introducing any added complexity for the programmer. This would enable both live authoring and live viewing of dynamic timed media, applicable in both single-device and collaborative, multi-device scenarios.</li> 
          <li><b>Simple usage</b></li>
        </ul>
     
        <p>
          In short, the <a>sequencing</a> mechanism should be made available as a generic programming concept/tool. This would presumably benefit both individual programmers as well as developers of advanced media frameworks. This specification extends the concept of <a>text track</a> to achieve this result so that application developers that already use <a>text tracks</a> driven by <a>media elements</a> may easily start using <a>timing text tracks</a> driven by a <a>timing object</a>.
        </p>

        <p class="note">
          An open-source JavaScript implementation of a <a>sequencing</a> mechanism is available [[SEQUENCER]] to allow developers to quickly start exploring the benefits of <a>sequencing</a> driven by a <a>timing object</a>. Please note that interfaces used in that implementation are not entirely aligned with those defined in this specification.
        </p>
      </section>

      <section>
        <h3>Timing text track</h3>
    
        <p>
          A <dfn data-lt="timing text tracks">timing text track</dfn> is a <a>text track</a> that is directed by a <a>timing object</a>. The <a>timing text track</a> includes <a>sequencing</a> logic for the set of <a>text track cues</a> that composes the <a>text track</a>. As such, a <a>timing text track</a> has a <dfn>current sequencer</dfn> which is the <a>timing object</a>.
        </p>
    
        <pre class="idl">
          [Exposed=Window]
          interface TimingTextTrack : TextTrack {
            constructor(TextTrackKind kind, optional DOMString label = "", optional DOMString language = "");
            attribute TimingObject timingsrc;
          };
        </pre>

        <p>
          The <dfn data-dfn-for="TimingTextTrack">timingsrc</dfn> attribute MUST, on getting, return the <a>current sequencer</a> of the <a>timing text track</a>, if any, or null otherwise. On setting, the <a>user agent</a> MUST <a>associate the track with a timing object</a>.
        </p>

        <p class="note">
          As opposed to a <a>text track</a>, a <a>timing text track</a> is not and cannot be associated with a <a>media element</a>.
        </p>
        <p class="issue">
          Is inheriting from <a>TextTrack</a> as proposed above the right approach? An alternative approach would be to extend <a>TextTrack</a> as done for the <a>HTMLMediaElement</a>. The problem with this appraoch is that <a>TextTrack</a> does not expose a constructor, so the only way to create a <a>timing text track</a> would be to add an <code>addTextTrack</code> method to the <a>timing object</a> (similar to the one on <a>HTMLMediaElement</a>). However, this is undesireable, as we would like to maintain a clean separation between <a>timing object</a> and objects that take direction from it. For instance, a clear separation ensures the flexibility to dynamically switch <a>timing object</a> for the <a>timing text track</a>. 
        </p>
        <p class="issue">
          Note also that the <a>TextTrack</a> design bear witness of close integration with <a>media elements</a>. For example, as the <a>media element</a> must provide UI support for <a>text track</a> visualization, it requires meta information such as track type (kind) and language. However, this meta information may quickly become irrelevant in a context where programmers are making custom timed presentations from application-specific data formats. Furthermore, as the programming of timed presentation is made very easy and flexible using the <a>timing object</a> combined with a general purpose <a>sequencing</a> mechanism, programmers will be much less dependent on the limited UI support for subtitles and captions, that is currently provided by <a>media elements</a>. In this perspective it seems odd to insist that all <a>timing text tracks</a> must be of a specific kind and declare a language. 
        </p>
        <p class="issue">
          A <a>media element</a> acts as <a>sequencer</a> for a list of <a>text tracks</a>. It is not clear that <a>timing text tracks</a> similarly need to be managed within a container. If such a container object is deemed necessary (e.g. for consistency with existing standards), such a container object must be defined in this document, say a <dfn>Timing Track</dfn>. The <a>sequencing</a> logic (<a>track marches on</a>) would then be provided by that container object rather than by <a>timing text tracks</a> individually.         
        </p>
        <p class="issue">
          There is a tradeoff with respect to how much we want <a>timing text tracks</a> to divert from regular <a>text tracks</a>. Keeping it true to its origins may be awkward in some respects. Taking it too far away may be confusing, possibly suggesting that a clean sheets approach with a new sequencer object might be preferable. Note also that programmers may use regular <a>text tracks</a> with a <a>media element</a>, a then let the <a>media element</a> be directed by a <a>timing object</a>.
        </p>
      </section>


      <section>
        <h3>Procedure: Create a new <a>timing text track</a></h3>
        <p>
          When the <code><a>TimingTextTrack</a></code> constructor is invoked, the <a>user agent</a> MUST run the following steps:
        </p>
        <ol>
          <li>Create a new <code><a>TimingTextTrack</a></code> object.</li>
          <li>Create a new <a>timing text track</a> corresponding to the new object, and sets its <a>text track kind</a> to <var>kind</var>, its <a>text track label</a> to <var>label</var>, its <var>text track language</var> to language, its <a>text track readiness state</a> to the <a>text track loaded</a> state, its <a>text track mode</a> to the <a>text track hidden</a> mode, and its <a>text track list of cues</a> to an empty list.</li>
          <li>Return the new <code><a>TimingTextTrack</a></code> object.</li>
        </ol>
      </section>

      <section>
        <h3>Procedure: Associate <a>timing text track</a> with a <a>timing object</a></h3>
        <p>
          When the <a>user agent</a> is required to <dfn>associate the track with a timing object</dfn>, it MUST run the following steps:
        </p>
        <ol>
          <li>Let <var>track</var> be the <a>timing text track</a> in question.</li>
          <li>Let <var>track</var>'s <a>current sequencer</a> be the new value.</li>
          <li>Run the <a>track marches on</a> algorithm of <var>track</var>.</li>
        </ol>

        <pre class="example highlight" title="Timed visualization of subtitles">
        var elem; // DOM element that renders subtitles
        var subtitles = [ // Timed data
          {text: "Zed's dead baby", start: 12.2, end: 17.4},
          {text: "Zed's dead", start: 19.7, end: 22.5}
        ];
        var track = new TimingTextTrack("metadata");
        subtitles.forEach(function (subtitle) {
          var cue = new DataCue(subtitle.start, subtitle.end, subtitle.text));
          track.addCue(cue);
        });
        var timing = new TimingObject(); 
        track.timingsrc = timing; // Associate timed data with timing object

        // React to cue changes (assuming only one active subtitle)
        track.addEventListener("cuechange", function () {
          var cue = (track.activeCues.length > 0) ? track.activeCues[0] : null;
          elem.innerHTML = cue ? cue.data : "";
        });
        timing.update({ velocity: 1.0 }); // Start playback
        </pre>
      </section>

      <section>
        <h3>Procedure: Track marches on</h3>
        <p>The <dfn>track marches on</dfn> procedure evaluates the state of the <a>timing text track</a> at a specific point in time. The procedure may cause events to be emitted, and it may also cause a timeout to be created for the next execution of the procedure. The user agent must run this procedure whenever:
        </p>
        <ul>
         <li>the <a>current sequencer</a> is set.</li>
         <li>the <a>current sequencer</a> emits a change event.</li>
         <li>a <a>text track cue</a> is added, modified or removed to the <a>timing text track</a>.</li>
         <li>an internal timeout signals that the procedure must be executed.</li>
        </ul>
        <p> 
          The specification does not detail the exact implementation of this procedure, except to note that the <a>track marches on</a> steps for the <a>timing text track</a> are essentially the same steps as the <a>time marches on</a> steps for a <a>media element</a>, replacing the <a>current playback position</a> by the <code>position</code> property of the <a>timing object</a> as returned by a call to <code>query().position</code> at the time of evaluation, and noting that <a>timing text tracks</a> do not have rules for updating the <a>text track</a> rendering, since the <a>timing text track</a> is UI-independent. Alternatively, the implementation of the <a>timing text track</a> may be based on the <a>sequencer</a> reference implementation. 
        </p>
      </section>

    </section>






    <section class="informative appendix">
      <h3>Implementation guidelines multi-device synchronization</h3>

      <p>
        Distributed synchronization is a main use case that a <a>user agent</a> or a <a>timing resource provider</a> may enable. <a>Timing objects</a> running on different devices will be synchronized if they are associated with the same online <a>timing resource</a>. To achieve precise and reliable synchronization across the Internet, the implementation needs to address two distinct issues: the synchronization of <a>state vectors</a> and the synchronization of clocks. A brief introduction to a specific solution is given below. Details are available in [[MSV]].
      </p>
      <p class="note">
        The guideline discusses communication between an <a>online timing resource</a> and a <a>timing object</a>. In reality though, these two entities do not communicate directly, but indirectly through a mediating <a href="#timing-provider-object">timing provider object</a> running on the user agent. In the perspective of the <a>timing object</a> the <a>timing provider object</a> is a proxy object for the <a>online timing resource</a>.
      </p>

      <section>
        <h3>State vector synchronization</h3>
        <p>
          If an <a>online timing resource</a> is updated, effects must apply equally to all connected <a>timing objects</a> as quickly as possible, including the <a>timing object</a> on which the update request might have been issued. This has implications for the processing of update requests. Local timing objects should simply forward the request, i.e. a new <a>state vector</a>), across the network to the <a>online timing resource</a>, where the request will be processed. Effects (i.e. the resulting <a>state vector</a>) will be multicast by the <a>online timing resource</a> to all connected <a>timing objects</a>, finally triggering a <code>change</code> event on these objects. Queries are always resolved locally, using the last <a>state vector</a> received from the <a>online timing resource</a>.
        </p>
        <p>
          Note that this strategy does not guarantee that <a>timing objects</a> emit <code>change</code> events exactly at the same time. It is possible to achieve this by adding additional delay (thereby masking the differences in network latency). This would be a trade-off against the responsiveness of the user experience.
        </p>
      </section>

      <section>
        <h3>Clock synchronization</h3>
        <p>
          Ideally, if multiple <a>timing objects</a> (e.g. on different devices) connected to the same <a>online timing resource</a> are queried at the exact same moment, they should ideally return the same <a>state vector</a> (same position, velocity and acceleration). This requires that <a>state vectors</a> are synchronized, and that the clock skew between <a>online timing resource</a> is zero (synchronized clocks) or known (so that it can be compensated).
        </p>
        <p>
          As synchronized system clocks is not a valid assumption in the Web environment, it follows that clock skew estimation must be resolved as part of the communication between <a>timing objects</a> and the <a>online timing resource</a>. To do this, <a>timing objects</a> (or <a>timing provider objects</a>) should maintain a software clock that is continuously synchronized with the clock used by the <a>online timing resource</a>. This may be achieved through periodic exchange with the <a>online timing resource</a> to evaluate the clock skew, taking into account the round-trip time (RTT) of these exchanges to improve the measurements. Using this evaluation, <a>timing objects</a> can tranform <a>state vectors</a> into the timeframe of their own local clock, i.e. the <a>internal clock</a>.
        </p>
        <p>
          Clock synchronization can be very fast. Stable estimates may be reached within fractions of a second. Implementations may for instance use an open Web sockets [[WEBSOCKETS]] connection to minimize the latency between <a>timing provider objects</a> and the <a>online timing resource</a>. If implemented correctly on both ends, this approach provides a basis to achieve &lt; 10ms media synchronization across the Internet.
        </p>
      </section>
    </section>










    <!-- USE CASES -->


    <section class="informative appendix">
      <h2>Use cases and requirements</h2>
      <p>
        Precise timing has wide applicability in both single-device and multi-device applications. Here we identify some common use cases.
      </p>


      <section>
      <h3> Social Viewing and Media Control</h3>
      <p>
        Allow people to enjoy the same content at the same time. Alice and Bob would like to watch the next episode together, even if Alice is on a train and Bob stays at home. If Alice pauses the video while briefly speaking with the conductor, Bob's video pauses too. Alice and Bob may always trust the other to see the exact same thing, making it very easy for them to maintain a conversation, for instance by using a chat service or the phone. It would also be possible for Alice and Bob to split temporarily. Alice would see Bob moving along the progress line without her, and Bob would see Alice staying behind. When Alice is ready to resume viewing a bit later, she may continue on her own, play doublespeed or skip to catch up with Bob, or convice Bob to wait for her or jump back to see the segment again with her.      
      </p>
      <p>
        This use case is based on <a href="https://www.w3.org/2011/webtv/wiki/New_Ideas">UC2-3 Identical Media Stream Synchronization</a>, a use case defined by the <a href="https://www.w3.org/2011/webtv/">W3C Web and TV Interest Group</a>
      </p>
      <p>
        This use case requires the management and sharing of multiple timing objects, at least one for Alice and one for Bob. Precision requirements for video synchronization are quite coarse as the use case is described. However, Alice and Bob might also choose to use this application in circumstances where they are sitting next to eachother, or they might hook their devices on to projectors in order to show a movie to a larger audience. Sub-framerate precision is required in order to avoid echo from device speakers. 
      </p>
      </section>

      <section>
      <h3> Broadcasting - Time-consistent, Live Web Productions </h3>
      <p>
        The BBC provides live coverage of popular sport events such as the FIFA World Cup. Modern Web presentations of this kind tend to include many independent media streams. For example, there might be multiple video streams for different camera angles, visualizations of players on the field, player statistics, and there might be commentary from studio as well as viewers. Earlier, Bob was annoyed that user comments could sometimes ruin the experience by shouting "GOAL!" 20 seconds before the goal appeared in the video stream. However, after BBC started timeshifting live Web content to match distribution latency in their video backend, this problem seems to be a thing of the past.
      </p>
      <p>
        This requires figuring out the estimated latency of the slowest distribution mechanism, and then to define a timing resource from which all parts of a presentation takes direction. In effect, early spoilers will be delayed (buffered) by the Web browsers and applied to UI components at the correct moment in time.
      </p>
      </section>

      <section>
      <h3> Broadcasting - Time-shifted, Live Web productions </h3>
      <p>
        A commercial media provider offers live Web content supplementing live broadcast of F1 races. Sometimes, as F1 races are held in different time zones, the provider will re-broadcast nightly races in the morning. As a keen F1 enthusiast, Alice is discontent that the Web content can not be time-shifted along with the re-broadcast of the race. So is Bob, the media provider's head of marketing, as he would like to sell time sensitive, Web-based ads for F1 races, and have the ads be presented correctly for both live and time-shifted broadcasts, as well as later on demand viewers.
      </p>
      <p>
        This requires timestamping of live Web production so that is may be time-shifted correctly and aligned with a time-shifted broadcast.
      </p>
      </section>

      <section>
      <h3> Broadcasting - Timed, Web-based Secondary Device </h3>
      <p>
        Alice opens the BBC Sport Web page on her iPad during the olympic games. The backend service consults Alice's profile and learns that she is already watching figure skating from the iPlayer on her laptop computer. As a result, the BBC Sports Web page is personalized with an offer to load BBC's Web-based extra material for figure skating. Alice accepts, and the iPad goes on to present stats, images, infographics, commentary and alternative camera angles, all precisely timed with the iPlayer. Alice notices that other viewers have already highlighted a Chinese athlete performing a bit earlier. She clicks to see it, and both the iPlayer (on the laptop) and the timed Web presentation (on the iPad) immediately skip back. After having seen the athlete's performance, now with added commentary provided by excited viewers, Alice contributes by giving it a thumbs up, and then clicks the back-to-live button. Both the laptop and the iPad snap back to presenting the live action.
      </p>
      <p>
        This use case is based on <a href="https://www.w3.org/2011/webtv/wiki/New_Ideas">UC2-4 Related Media Stream Synchronization</a>, a use case defined by the <a href="https://www.w3.org/2011/webtv/">W3C Web and TV Interest Group</a>
      </p>
      <p>
        This use case requires managing personal timing resources for individual viewers, as well as a common timing resource representing the live clock. Both iPlayer and Web-based secondary device offerings must take direction from online timing resources, and allow dynamic switching of timing objects based on user input. Presenting alternative camera angles as part of secondary device offerings requires precise synchronization.   
      </p>
      </section>


      <section>
      <h3> Online Education - Timed, Multi-device Web Presentations </h3>
      <p>
        Alice teaches an online course for international students from across the globe. Every week she goes through a new Web-based slide set. Just before the session, she makes two links available for her students on the class Web page, links for the primary and the secondary view of the presentation. When the time is there she connects on an audio link and requests the first slide to be presented. Slides are presented on her view and on all the views of her connected students, at exactly the same time. This way, Alice can be sure that what she says on the audio link is always backed up with the correct illustrations. In effect, Alice remotely controls the Web browsers of all her students. Alice also has included a video in one of the slides. She plays the video for all the students on the primary view, while presenting some related bullet points on the secondary view. Alice pauses the video at a certain point in order to highlight an important aspect. Beforehand she has prepared some bookmarks in the video, allowing her to effectively skip to the interesting parts. At some point one of the students has a question related to the movie. Alice temporarily gives the student access to control the video, and the student rewinds it to explain the origin of his question. Afterwards, Alice withdraws the controls from the student and continues. The entire event is recorded and timestamped, allowing students that missed the class to replay the audio with and the slide presentation precisely as it was given. This review also provides synchronized presentations of timed comments provided by students as well as text-based search capabilities allowing efficient navigation within the presentation.         
      </p>
      <p>
        Multi-device slide show navigation requires a single shared timing resource, where position represents slide number. Videos require additional timing resources. Finally, timestamping of audio, slide navigation, video navigation, students commentary etc., require an addition timing resource as shared clock. Later individual replay might also require new timing resources.  
      </p>
      </section>


      <section>
      <h3> Multi-Screen Data Visualization </h3>
      <p>
        Bob is heading a research project responsible for collecting and presenting a variety of data series related to climate changes in the Arctic. A Web-based approach to visualization makes for a very dynamic and extensible visualization system. Multiple screens may be used to present and align very different timed visualizations, making it easier to detect temporal patterns and possible correlations. The different visualizations may be navigated in unison. For instance, Bob may slow down the presentation speed for the heavy melting days to co-present this with measurements of salinity levels in the ocean water. Bob may also search his data to find the day with the highest temperature. By clicking on the result, all screens immediately display the relevant data for that day. Alice is recognized as an international expert in this area. Bob shares the link with Alice in an email, they may co-view the presentation even though they are stationed in different continents, and Alice may explore the visualization herself before giving her opinion of Bob's finding. 
      </p>
      <p>
        A shared timing resource is required to support playback of timed data streams on multiple screens. The utility is not limited to Web-based visualization. For instance, native visualization frameworks (e.g. 3D) may also interact with multi-device timing resources, thus enabling very different visualization systems to cooperate in presenting a common data model. 
      </p>
      </section>



      <section>
      <h3> Seamless Workflows </h3>
      <p>
        Bob is watching a Netflix show using Chromecast on the TV when Alice interrupts and demands access to the living room big screen for herself and her friends. Bob reluctantly agrees to finish the show in his bedroom. Though, before he gets up he opens Netflix on his iPad. Netflix, well aware that Bob is already actively watching something, defaults to presenting the exact same thing, in perfect synchrony with the TV. Ensured that the transition was smooth, Bob leaves for his bedroom while staring at his iPad.
      </p>
      <p>
        The use case requires online timing resources and content resources to be tied to login information. So, when an already logged in user enters a VoD service with a second device, the default action could be to resolve which show is already playing and what timing resource is being used, and then to set up the new view with the exact same resources. 
      </p>
      </section>


      <section>
      <h3> Alternative Soundtracks </h3>
      <p>
        Alice's Portuguese mother has a hearing deficiency, so as the two of them sit down to watch a movie together, Alice hooks her smart phone up with the Portuguese audio track and lets her mother adjust the sound volume. Any issues with lip-sync should be due to the dubbing, not the audio synchronization.
      </p>
      <p>
        This use case is based on <a href="https://www.w3.org/2011/webtv/wiki/New_Ideas">UC2-6 Clean Audio</a>, a use case defined by the <a href="https://www.w3.org/2011/webtv/">W3C Web and TV Interest Group</a>
      </p>
      <p>
        This requires lip-synch precision between video and audio. 
      </p>
      </section>


      <section>
      <h3> Timing Interoperability between Independent Providers </h3>
      <p>
        Bob watches soccer. Unfortunately, the clueless commentator is constantly pissing him off as he clearly favours the other team. Bob turns to a dedicated Web radio channel for an alternative commentary. The new commentator is better, but he is out of sync. Bob chooses the <i>SyncWith</i> option in the radio channel Web page and selects his TV provider. After confirming his credentials, the radio channel Web page is able to connect to the same timing resource used by the TV provider, and the Web radio is immediately in sync with his TV.
      </p>
      <p>
        This use case requires media providers to give access to timing resources associated with a given user, also when that user is requesting access from an external service. Synchronization of audio and video requires lip-synch precision.
      </p>
      </section>
 

      <section>
      <h3> Linear Content Adaptation </h3>
      <p>
        Bob is watching cricket, but he and Alice soon need to get in the car to start the long drive to visit Bob's parents. He would like to keep following the cricket game on his smart phone, but does not have the bandwidth nor the money to enjoy HD content. Instead, Bob selects the timed HTML option. The audio goes on undisturbed, but the HD video is immediately terminated and replaced with a light-weight, timed animation of the cricket field. Alice is behind the wheels, and Bob may continue to enjoy the cricket match through audio and full support from all the HTML-based extra information. 
      </p>
      <p>
        Shared timing resources allow smooth and dynamic switching from HD to timed-based HTML.   
      </p>
      </section>

      <section>
      <h3> Distributed Capture and Replayability </h3>
      <p>
        Web browsers are increasingly useful for capturing user generated data. The trivial example is basic interaction, where users manually post comments or upload media. More interestingly, browser integration with peripheral devices such as Web-cameras and microphones allow Web browsers to become input devices for live, distributed media productions. Also, mobil devices come with a range of built-in sensors. All this imput data may become even more valuable if it is timestamped according to the same clock. The timing objects, with support for multi-device synchronization enables precise timestamping of media capture for distributed phenomena. Furthermore, the same data may be replayed time-shifted in multi-screen presentations using the timing object as playback director.
      </p>
      <p>
        Shared timing resources enables timed capture and preservation of timing relations in the distributed scenario.
      </p>
      </section>

      <section>
      <h3> Distributed Music Production and Playback  </h3>
      <p>
        Musical productions are naturally distributed when multiple instruments play together. In the domain of music orchestration, the MIDI protocol has been uses as a carrier of tempo and rythm among electronic instruments. However, as MIDI signals are broadcast over physical (and wireless) links, higher latency reduces the synchronization. For this reason, the use of MIDI orchestration is typically limited to in-house setups. In contrast, the timing object with support for online synchronization supports millisecond precision globally, opening up for innovative distributed musical experiences. It also allows the involvement of visual components and devices that are not instruments. Support for MIDI instruments can still be achieved by synchronization of MIDI controllers using the timing object.   
      </p>
      <p>
        Shared timing resources closes the gap between the world of musical orchestration and multi-device orchestration in the Web.
      </p>
      </section>

      <section>
      <h3> Ad-insertion and Time-sensitive Ads </h3>
      <p>
        Seamless switching between video content and inserted segments of Ads is identified as an important use case for commercial interests. <a href="https://www.w3.org/wiki/HTML/Media_Task_Force/MSE_Ad_Insertion_Use_Cases">Media Task Force Ad Insertion Use Cases</a>. Support for precisely timed playback of video elements is the basis for seamless switching. The timing object object may define a common timeline for both main content and ads, and timed text track support may be used to schedule videos in and out at the correct time, possibly with cross-fading implememted in css. The timing text track may even be used to implement pre-loading of videos, so that they are ready to play content just before a video switch. Using a timing object as director of media playback like this additionally opens up the possibility of presenting time-sensitive ads at the right time, possibly on a secondary device.
      </p>
      <p>
        The timing object enables seamless, dynamic switching between different sources of timed media, and opens up for timed advertisements on multiple devices.
      </p>
      </section>
    </section>

    <section id="idl-index" class="appendix">
  </body>
</html>
