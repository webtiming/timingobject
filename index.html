<!DOCTYPE html>
<html>
  <head>
    <title>Timing Object</title>
    <meta charset="utf-8">
    <script src="http://www.w3.org/Tools/respec/respec-w3c-common"
            async class="remove"></script>
    <script class="remove">
      var respecConfig = {
          specStatus: "ED",
          edDraftURI: "http://webtiming.github.io/timingobject",
          shortName:  "timing-object",
          editors: [
            {
              name:       "François Daoust",
              company:    "W3C",
              companyURL: "http://www.w3.org",
              mailto:     "fd@w3.org"
            },
            {
              name:       "Ingar M. Arntzen",
              company:    "Motion Corporation",
              companyURL: "http://motioncorporation.com/",
              mailto: "ingar.arntzen@motioncorporation.com"
            }
          ],
          authors: [
            {
              name:       "Njål T. Borch",
              company:    "Motion Corporation",
              companyURL: "http://motioncorporation.com/",
              mailto: "njaal.borch@motioncorporation.com"
            }
          ],
          wg:           "Multi-Device Timing Community Group",
          wgURI:        "http://www.w3.org/community/webtiming/",
          wgPublicList: "public-webtiming",

          localBiblio:  {
            "LINEARCOMPOSITION": {
              title: "Multi-device Linear Composition on the Web: Enabling Multi-device Linear Media with HTMLTimingObject and Shared Motion",
              href: "https://sites.google.com/site/mediasynchronization/Paper4_Arntzen_webComposition_CR.pdf?attredirects=0&d=1",
              authors: [
                "Ingar M. Arntzen",
                "Njål T. Borch",
                "François Daoust",
                "Dominique Hazaël-Massieux"
              ]
            },
            "MSV": {
              title:    "The Media State Vector: A unifying concept for multi-device media navigation",
              href:     "http://dl.acm.org/citation.cfm?doid=2457413.2457427",
              authors:  [
                "Ingar M. Arntzen",
                "Njål T. Borch",
                "Christopher P. Needham"
              ]
            },
            "DVB-CSS": {
              title: "ETSI TS 103 256-2 V1.1.1 Digital Video Broadcasting (DVB); Companion Screens and Streams; Part 2: Content Identification and Media Synchronization",
              href: "http://www.etsi.org/modules/mod_StandardSearch/pdf.png"
            }
        }
      };
    </script>
    <style type="text/css">
      table { border-collapse: collapse; border-style: hidden hidden none hidden; }
      table thead, table tbody { border-bottom: solid; }
      table td, table th { border-left: solid; border-right: solid; border-bottom: solid thin; vertical-align: top; padding: 0.2em; }
    </style>
  </head>
  <body>



  <!-- ABSTRACT -->

    <section id="abstract">
      <p>
        This specification defines a timing object and an associated API. The timing object is a local object that may be used by Web clients to ensure precisely timed execution. If multiple time-sensitive components take direction from the same timing object, their behaviour will be precisely coordinated in time. Crucially, this is also the case in distributed settings. A central motivation for the timing object is that it may be connected to an online timing resource. This way, the local timing object is a gateway to precisely timed operations, both in single-device as well as multi-device scenarios.
      </p>
  

      <p class="note">
        This timing object is not to be confused with concepts proposed by 
        <a href="https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/NavigationTiming/Overview.html">Navigation Timing</a>, an initiative targeting precise measurement of time consumption in Web browsers.
      </p>

    </section>






    <section id="sotd">
      <p>
        The specification is intended for discussion within the Multi-Device Timing Community Group. Its content does not yet represent the consensus of the Community Group.
      </p>
      <p class="warning">
        This specification is incomplete. Some procedures are either missing or described as <em>similar to procedures defined in [[!HTML5]]</em>. The main goal of this draft is to propose a technical solution, show how it could be integrated in [[!HTML5]] and gather feedback from interested parties before dwelving into details.
      </p>
    </section>
    




    <!-- INTRODUCTION -->


    <section class="informative">
      <h2>Introduction</h2>
      
      <p>
        Timing mechanisms allow operations to be executed at the correct time. The Web already has several mechanisms supporting timed operations, including <code>setTimeout</code>, <code>setInterval</code>, as well as controllers for media frameworks and animations. Unfortunately, these mechanisms are limited in scope, as they only apply to timed operations within a single web page. The <a href="https://www.w3.org/community/webtiming/">W3C Multi-device Timing Community Group</a> has been formed with the goal of extending the Web with native support for precisely timed operation across Web pages hosted by different devices, as well as providing a unifying model to which all frameworks for timed operation may integrate. The timing object is the central concept in this initiative.
      </p>

      <p>
        Synchronized playback of multi-device linear media is an important use-case for multi-device timing. However, multi-device timing has wide utility for a variety of timing related challenges, including distributed media control and remote control, distributed synchronization, distributed time-shifting, distributed time-ordering and distributed recording (time-stamping). This way, multi-device timing has applicability in many application domains, including TV and radio (broadcast and IP-based), secondary device applications, online education, video on demand services, scientific visualization, music etc.
      </p>

 
      




      <section>
        <h3>Linear composition</h3>

        <p>
          <dfn>Linear composition</dfn> is simply the idea that complex linear media can be built from simpler, independent linear components. This way, the classical benefits of composition as a design principle, i.e. flexibility, reusability, extensibility and mashup-ability, would fully apply to linear media. For example, in the single-device scenario, imagine a linear presentation made from HTML5 video, some timed meta-information, a SMIL component, a Web Animation, a map with timed georeferenced data, and a timed Twitter widget. Or, in the multi-device scenario, imagine the same components distributed or duplicated across multiple devices. In both cases linear composition requires interoperability of heterogeneous linear components, through precisely coordinated, timed playback.
        </p>
        <p>
          Up until now, each framework has defined its own custom timing control mechanisms, which makes it difficult to achieve <a>linear composition</a> in practice. The central purpose of the timing object is thus to simplify interoperability by providing a common basis for timing control in linear media.
        </p>
        <p>
          For a more detailed introduction on linear composition, see [[LINEARCOMPOSITION]].
        </p>
      </section>

      <section>
        <h3>Design goals and architecture</h3>

        <p>
          The design of the timing object has two main goals:
        </p>
        <ol>
          <li>
            <b>provide a unifying API for timed operation</b> that other frameworks &mdash; such as the notion of <em>media timeline</em> in [[HTML5]], <em>timelines</em> in Web Animations [[WEB-ANIMATIONS-1]], <em>timestamps</em> in the Web Audio API [[WEBAUDIO]] and SMIL Timing [[SMIL3]] &mdash; can integrate with. The API must support highly precise timing, and be expressive enough to support control primitives appropriate for a wide range of media types and applications.
          </li>
          <li> 
            <b>encapsulate complexity of distributed time synchronization</b>, thereby allowing integrating frameworks to be included in precisely timed multi-device operation. In particular, by providing the same API for local and online timing resources, timed components may be used in single-device and multi-device scenarios, without modification. 
          </li>
        </ol>

        <p>
          <a href="#fig-timingobject-overview">Fig. 1</a> below illustrates these functions, as well as the underlying client-server architecture. In this example, a timing object is instantiated on each of the three devices, and each instance is connected to a single, shared online timing resource. On each device, the timing object acts as the director for independent, time-sensitive GUI components. This way, a video will aim to present video frames in accordance with the timing resource. Similarly, a time-sensitive Twitter widget might replay time-stamped Tweets. If the timing object pauses, the connected components are notified and react accordingly.
        </p>

        <figure id="fig-timingobject-overview">
          <img src="overview.png" width="400" alt="The image illustrates the concept of an online timing resource how it used to synchronize HTTPTimingObjects across three different Web clients." />
          <figcaption>Timing objects on three devices connected to the same online timing resource</figcaption>
        </figure>

        <p>
          The different components can go about their business in complete isolation. There is no need for components to communicate, except indirectly through the timing object. This loose coupling is the key to linear composability.
        </p>
        <p>
          Furthermore, when timing objects are connected to an online timing resource, they merely act as local representatives. For example, when requested to pause, the timing object will simply forward the request to the online timing resource. As the online object pauses, notifications will be multicast to all connected clients. The timing object will only update its internal state and notify connected UI components when it receives this notification. For online timing objects, clients can expect update latency of about one round trip time (RTT), whereas local timing resources should have no update latency. Apart from this, online and local timing resources should be hard to distinguish. Note also that the argument made for the independence of time-sensitive components in the single-device scenario now applies to the multi-device scenario as well. 
        </p>

        <p class="note">
          This specification describes the integration of timing objects with HTML5 Media elements and text tracks. Integration with other frameworks for timed operation, such as Web Animation, SMIL, and Web Audio [[!HTML5]] will be covered separately.
        </p>
      </section>

      <section>
        <h3>The timing object</h3>
        <p>
          A timing object is conceptually a very simple object, essentially an advanced stop watch (<a href="#fig-stopwatch">Fig. 2</a>). If started, its value changes predictably in time, until at some point later, it is paused, or perhaps reset. It may be queried for its value at any time. For example, it should take exactly 2.0 seconds for the value to advance from 3.0 to 5.0 when the velocity is 1.0. Such deterministic behavior is required for reliable distributed synchronization. In terms of implementation, the timing object is a fairly thin wrapping around a monotonic system clock (integration with online timing resources adds a bit of complexity). The precision of the timing object is that of the monotonic system clock.
        </p>
        <figure id="fig-stopwatch">
          <img src="stopwatch_digital.jpg" width="160" alt="The timing object is essentially and advanced stop watch." />
          <figcaption>The timing object is essentially an advanced stop watch.</figcaption>
        </figure>

        <p>
          A timing object is more expressive than a traditional stop watch. It supports any velocity or acceleration, and may jump to any position on the timeline (<a href="#fig-timeline">Fig. 3</a>). In fact, a timing object essentially implements <em>linear motion along a unidimensional axis</em>. State vectors [[MSV]], based on the classical equations of linear motion under constant acceleration, are used to represent that motion. At any point in time, position, velocity or acceleration may be requested to change. Querying the timing object reveals not only its current position but also its velocity and acceleration at that moment. The expressiveness of this model implies that a wide variety of control primitives can be supported. For example, discrete jumps on the timeline may be used to control a slide show, or velocity may correspond to <code>playbackRate</code> for the control of continuous media. Acceleration may be required by animation frameworks.
        </p>

        <figure id="fig-timeline">
          <img src="timeline.png" width="400" alt="The timing object is essentially and advanced stop watch." />
          <figcaption>The timing object visualized as a cursor moving along a timeline.</figcaption>
        </figure>
      </section>

      <section>
        <h3>Programming with timing objects</h3>

        <p>
          Timing objects are resources used by your application, and you may define as many as you like. What purposes they serve in the application is up to the programmer. If the application needs a shared, multi-device clock, just start a timing object and make sure you never stop it. If you want the clock value to represent milliseconds, just set the velocity to 1000 (advances the timing object with 1000 milliseconds per second). If the timing object represents media offset, just specify the playback position, the velocity, and perhaps a media duration. For video you might measure offset in seconds or frames and set the velocity accordingly. Or, for musical applications it may be practical to let the timing object represent beats per second. Note also that the timing object may represent time-changes with any kind of variable. For instance, if you have data that is organized according to, say height above sea level, you may want to animate how this data changes as you move vertically. In this case the timing object might represent meters or feet above sea level, and positive and negative velocities would allow you to move both upwards and downwards.
        </p>
        <p>
          In general, the timing object is particularly useful when you have a variable that needs to change predictably in time.
        </p>
      </section>


      <section>
        <h3>Media capture and playback</h3>

        <p>
          Two very common uses of the timing object include media capture and playback. For media playback, the  timing object may play the role of director/controls. Multiple independent components, possibly on different devices, may be responsible for timed presentation of timed media. If all components take direction from a single timing object, playback is ensured to be consistent.
        </p>
        <p>
          For media capture, the timing object may represent a shared clock for timestamping various types of captured media, also in multi-device scenarios. As long as timestamps are sampled from a shared clock and included in the captured media, time-shifted playback is possible. In live capturing scenarios, the timing object should likely just run continuously like a clock, or perhaps be adjusted slightly from time to time to stay in sync with some real-world clock source, e.g. epoch. However, media capture in a studio may be a much more iterative process, recording one track or sample at a time. In such scenarios, the timing object might have to be paused and rewound for each take. The timing object will then play the dual role of playback director for previously captured media, as well as production clock for current capture.
        </p>
      </section>

      <section>
        <h3>Reference point in capture and playback</h3>

        <p>
          The concept of reference point refers to the exact time-alignment of timing object and media in capture and playback. Disagreement about the details of this alignment is a source of (small) synchronization errors. For this reason, a common definition of reference points for time alignment in capture and playback is helpful.
        </p>
        <p>
          For media capture, media timestamps should reflect the point in time when external, physical signals are received by sensors. I.e., ideally when photons hit the lense or when sound waves hit the microphone. So, as timestamping activity is delayed relative to this ideal reference point, timestamps picked from the timing object must be adjusted (upstream delay subtracted). This implies that capturing components must know (or figure out) their upstream latency. If all components are able to do this correctly, variation in processing delay will not produce synchronization errors.  
        </p>
        <p>
          For media playback, media timestamps should reflect the point in time when timed media fragments take physical effect. I.e., ideally when pixels are modified on the screen, or when the loudspeaker modifies its vibration frequency. If playback commands are subject to non-negligible delay before they take effect, the playback component must schedule commands earlier. This implies that playback component must know (or figure out) their downstream delay. If all components are able to do this correctly, variation in processing delay will not produce synchronization errors.  
        </p>
        <p class="note">
          This definition of reference points is in accordance with definitions used in related standardization work, for instance see [[DVB-CSS]] / HbbTV2.0 CSS clause 5.7.2.
        </p>
        <p class="note">
          Strictly speaking, the timing object is usage-agnostic and can not mandate a specific definition for reference point. However, as interoperability of timing-sensitive components (e.g. capture and playback) is a major motivation for the timing object, the above definitions for reference point are recommended.  
        </p>
      </section>
    </section>












    <!-- USE CASES -->


    <section class="informative">
      <h2>Use cases and requirements</h2>
      <p>
        Precise timing has wide applicability in both single-device and multi-device applications. Here we identify some common use cases.
      </p>


      <section>
      <h3> Social Viewing and Media Control</h3>
      <p>
        Allow people to enjoy the same content at the same time. Alice and Bob would like to watch the next episode together, even if Alice is on a train and Bob stays at home. If Alice pauses the video while briefly speaking with the conductor, Bob's video pauses too. Alice and Bob may always trust the other to see the exact same thing, making it very easy for them to maintain a conversation, for instance by using a chat service or the phone. It would also be possible for Alice and Bob to split temporarily. Alice would see Bob moving along the progress line without her, and Bob would see Alice staying behind. When Alice is ready to resume viewing a bit later, she may continue on her own, play doublespeed or skip to catch up with Bob, or convice Bob to wait for her or jump back to see the segment again with her.      
      </p>
      <p>
        This use case is based on <a href="http://www.w3.org/2011/webtv/wiki/New_Ideas">UC2-3 Identical Media Stream Synchronization</a>, a use case defined by the <a href="http://www.w3.org/2011/webtv/">W3C Web and TV Interest Group</a>
      </p>
      <p>
        This use case requires the management and sharing of multiple timing objects, at least one for Alice and one for Bob. Precision requirements for video synchronization are quite coarse as the use case is described. However, Alice and Bob might also choose to use this application in circumstances where they are sitting next to eachother, or they might hook their devices on to projectors in order to show a movie to a larger audience. Sub-framerate precision is required in order to avoid echo from device speakers. 
      </p>
      </section>

      <section>
      <h3> Broadcasting - Time-consistent, Live Web Productions </h3>
      <p>
        The BBC provides live coverage of popular sport events such as the FIFA World Cup. Modern Web presentations of this kind tend to include many independent media streams. For example, there might be multiple video streams for different camera angles, visualizations of players on the field, player statistics, and there might be commentary from studio as well as viewers. Earlier, Bob was annoyed that user comments could sometimes ruin the experience by shouting "GOAL!" 20 seconds before the goal appeared in the video stream. However, after BBC started timeshifting live Web content to match distribution latency in their video backend, this problem seems to be a thing of the past.
      </p>
      <p>
        This requires figuring out the estimated latency of the slowest distribution mechanism, and then to define a timing resource from which all parts of a presentation takes direction. In effect, early spoilers will be delayed (buffered) by the Web browsers and applied to UI components at the correct moment in time.
      </p>
      </section>

      <section>
      <h3> Broadcasting - Time-shifted, Live Web productions </h3>
      <p>
        A commercial media provider offers live Web content supplementing live broadcast of F1 races. Sometimes, as F1 races are held in different time zones, the provider will re-broadcast nightly races in the morning. As a keen F1 enthusiast, Alice is discontent that the Web content can not be time-shifted along with the re-broadcast of the race. So is Bob, the media provider's head of marketing, as he would like to sell time sensitive, Web-based ads for F1 races, and have the ads be presented correctly for both live and time-shifted broadcasts, as well as later on demand viewers.
      </p>
      <p>
        This requires timestamping of live Web production so that is may be time-shifted correctly and aligned with a time-shifted broadcast.
      </p>
      </section>

      <section>
      <h3> Broadcasting - Timed, Web-based Secondary Device </h3>
      <p>
        Alice opens the BBC Sport Web page on her iPad during the olympic games. The backend service consults Alice's profile and learns that she is already watching figure skating from the iPlayer on her laptop computer. As a result, the BBC Sports Web page is personalized with an offer to load BBC's Web-based extra material for figure skating. Alice accepts, and the iPad goes on to present stats, images, infographics, commentary and alternative camera angles, all precisely timed with the iPlayer. Alice notices that other viewers have already highlighted a Chinese athlete performing a bit earlier. She clicks to see it, and both the iPlayer (on the laptop) and the timed Web presentation (on the iPad) immediately skip back. After having seen the athlete's performance, now with added commentary provided by excited viewers, Alice contributes by giving it a thumbs up, and then clicks the back-to-live button. Both the laptop and the iPad snap back to presenting the live action.
      </p>
      <p>
        This use case is based on <a href="http://www.w3.org/2011/webtv/wiki/New_Ideas">UC2-4 Related Media Stream Synchronization</a>, a use case defined by the <a href="http://www.w3.org/2011/webtv/">W3C Web and TV Interest Group</a>
      </p>
      <p>
        This use case requires managing personal timing resources for individual viewers, as well as a common timing resource representing the live clock. Both iPlayer and Web-based secondary device offerings must take direction from online timing resources, and allow dynamic switching of timing objects based on user input. Presenting alternative camera angles as part of secondary device offerings requires precise synchronization.   
      </p>
      </section>


      <section>
      <h3> Online Education - Timed, Multi-device Web Presentations </h3>
      <p>
        Alice teaches an online course for international students from across the globe. Every week she goes through a new Web-based slide set. Just before the session, she makes two links available for her students on the class Web page, links for the primary and the secondary view of the presentation. When the time is there she connects on an audio link and requests the first slide to be presented. Slides are presented on her view and on all the views of her connected students, at exactly the same time. This way, Alice can be sure that what she says on the audio link is always backed up with the correct illustrations. In effect, Alice remotely controls the Web browsers of all her students. Alice also has included a video in one of the slides. She plays the video for all the students on the primary view, while presenting some related bullet points on the secondary view. Alice pauses the video at a certain point in order to highlight an important aspect. Beforehand she has prepared some bookmarks in the video, allowing her to effectively skip to the interesting parts. At some point one of the students has a question related to the movie. Alice temporarily gives the student access to control the video, and the student rewinds it to explain the origin of his question. Afterwards, Alice withdraws the controls from the student and continues. The entire event is recorded and timestamped, allowing students that missed the class to replay the audio with and the slide presentation precisely as it was given. This review also provides synchronized presentations of timed comments provided by students as well as text-based search capabilities allowing efficient navigation within the presentation.         
      </p>
      <p>
        Multi-device slide show navigation requires a single shared timing resource, where position represents slide number. Videos require additional timing resources. Finally, timestamping of audio, slide navigation, video navigation, students commentary etc., require an addition timing resource as shared clock. Later individual replay might also require new timing resources.  
      </p>
      </section>


      <section>
      <h3> Multi-Screen Data Visualization </h3>
      <p>
        Bob is heading a research project responsible for collecting and presenting a variety of data series related to climate changes in the Arctic. A Web-based approach to visualization makes for a very dynamic and extensible visualization system. Multiple screens may be used to present and align very different timed visualizations, making it easier to detect temporal patterns and possible correlations. The different visualizations may be navigated in unison. For instance, Bob may slow down the presentation speed for the heavy melting days to co-present this with measurements of salinity levels in the ocean water. Bob may also search his data to find the day with the highest temperature. By clicking on the result, all screens immediately display the relevant data for that day. Alice is recognized as an international expert in this area. Bob shares the link with Alice in an email, they may co-view the presentation even though they are stationed in different continents, and Alice may explore the visualization herself before giving her opinion of Bob's finding. 
      </p>
      <p>
        A shared timing resource is required to support playback of timed data streams on multiple screens. The utility is not limited to Web-based visualization. For instance, native visualization frameworks (e.g. 3D) may also interact with multi-device timing resources, thus enabling very different visualization systems to cooperate in presenting a common data model. 
      </p>
      </section>



      <section>
      <h3> Seamless Workflows </h3>
      <p>
        Bob is watching a Netflix show using Chromecast on the TV when Alice interrupts and demands access to the living room big screen for herself and her friends. Bob reluctantly agrees to finish the show in his bedroom. Though, before he gets up he opens Netflix on his iPad. Netflix, well aware that Bob is already actively watching something, defaults to presenting the exact same thing, in perfect synchrony with the TV. Ensured that the transition was smooth, Bob leaves for his bedroom while staring at his iPad.
      </p>
      <p>
        The use case requires online timing resources and content resources to be tied to login information. So, when an already logged in user enters a VoD service with a second device, the default action could be to resolve which show is already playing and what timing resource is being used, and then to set up the new view with the exact same resources. 
      </p>
      </section>


      <section>
      <h3> Alternative Soundtracks </h3>
      <p>
        Alice's Portuguese mother has a hearing deficiency, so as the two of them sit down to watch a movie together, Alice hooks her smart phone up with the Portuguese audio track and lets her mother adjust the sound volume. Any issues with lip-sync should be due to the dubbing, not the audio synchronization.
      </p>
      <p>
        This use case is based on <a href="http://www.w3.org/2011/webtv/wiki/New_Ideas">UC2-6 Clean Audio</a>, a use case defined by the <a href="http://www.w3.org/2011/webtv/">W3C Web and TV Interest Group</a>
      </p>
      <p>
        This requires lip-synch precision between video and audio. 
      </p>
      </section>


      <section>
      <h3> Timing Interoperability between Independent Providers </h3>
      <p>
        Bob watches soccer. Unfortunately, the clueless commentator is constantly pissing him off as he clearly favours the other team. Bob turns to a dedicated Web radio channel for an alternative commentary. The new commentator is better, but he is out of sync. Bob chooses the <i>SyncWith</i> option in the radio channel Web page and selects his TV provider. After confirming his credentials, the radio channel Web page is able to connect to the same timing resource used by the TV provider, and the Web radio is immediately in sync with his TV.
      </p>
      <p>
        This use case requires media providers to give access to timing resources associated with a given user, also when that user is requesting access from an external service. Synchronization of audio and video requires lip-synch precision.
      </p>
      </section>
 

      <section>
      <h3> Linear Content Adaptation </h3>
      <p>
        Bob is watching cricket, but he and Alice soon need to get in the car to start the long drive to visit Bob's parents. He would like to keep following the cricket game on his smart phone, but does not have the bandwidth nor the money to enjoy HD content. Instead, Bob selects the timed HTML option. The audio goes on undisturbed, but the HD video is immediately terminated and replaced with a light-weight, timed animation of the cricket field. Alice is behind the wheels, and Bob may continue to enjoy the cricket match through audio and full support from all the HTML-based extra information. 
      </p>
      <p>
        Shared timing resources allow smooth and dynamic switching from HD to timed-based HTML.   
      </p>
      </section>

      <section>
      <h3> Distributed Recording and Replayability </h3>
      <p>
        use case ...
      </p>
      <p>
        requirements ...
      </p>
      </section>

      <section>
      <h3> Distributed Music Production and Playback  </h3>
      <p>
        use case ...
      </p>
      <p>
        requirements ...
      </p>
      </section>

      <section>
      <h3> Time sensitive Interactive Commercials </h3>
      <p>
        use case ...
      </p>
      <p>
        requirements ...
      </p>
      </section>
    </section>










    <!-- CONFORMANCE -->

    <section id="conformance">
      <p>
        Requirements phrased in the imperative as part of algorithms (such as "strip any leading space characters" or "return false and terminate these steps") are to be interpreted with the meaning of the key word ("must", "should", "may", etc.) used in introducing the algorithm.
      </p>

      <p>
        Conformance requirements phrased as algorithms or specific steps may be implemented in any manner, so long as the end result is equivalent. (In particular, the algorithms defined in this specification are intended to be easy to follow, and not intended to be performant).
      </p>

      <p>
        This specification defines conformance criteria for two classes of products:
      </p>

      <ul>
        <li>A <dfn>user agent</dfn> that provides the Web runtime and implements all the interfaces defined in <a href="#timing-object"></a>, <a href="#state-vector"></a>, and <a href="#interval-object"></a>.</li>
        <li>A <dfn>timing resource provider</dfn> that provides whatever logic is necessary to associate a <a>timing object</a> with a <a>timing resource</a> running online. A <a>timing resource provider</a> implements the <code><a>TimingProvider</a></code> interface defined in <a href="#timing-provider"></a>.</li>
      </ul>
    </section>











    <!-- TERMINOLOGY -->

    <section>
      <h2>Terminology</h2>

      <p>
        The following terms, procedures and interfaces are defined in [[!HTML5]]:
      </p>
      <ul>
        <li><dfn title="event handler|event handlers"><a href="http://www.w3.org/html/wg/drafts/html/master/webappapis.html#event-handlers">event handler</a></dfn></li>
        <li><dfn><a href="http://www.w3.org/html/wg/drafts/html/master/webappapis.html#event-handler-event-type">event handler event type</a></dfn></li>
        <li><dfn><a href="http://www.w3.org/html/wg/drafts/html/master/webappapis.html#queue-a-task">queue a task</a></dfn></li>
        <li><dfn><a href="http://www.w3.org/html/wg/drafts/html/master/webappapis.html#fire-a-simple-event">fire a simple event</a></dfn></li>
        <li><dfn title="media element|media elements"><a href="http://www.w3.org/html/wg/drafts/html/master/webappapis.html#media-element">media element</a></dfn></li>
        <li><dfn><a href="http://www.w3.org/html/wg/drafts/html/master/webappapis.html#media-timeline">media timeline</a></dfn></li>
        <li><dfn><a href="http://www.w3.org/html/wg/drafts/html/master/webappapis.html#effective-playback-rate">effective playback rate</a></dfn></li>
        <li><dfn><a href="http://www.w3.org/html/wg/drafts/html/master/webappapis.html#current-media-controller">current media controller</a></dfn></li>
        <li><dfn><a href="http://www.w3.org/html/wg/drafts/html/master/webappapis.html#slaved-media-elements">slaved media elements</a></dfn></li>
        <li><dfn><a href="http://www.w3.org/html/wg/drafts/html/master/webappapis.html#report-the-controller-state">report the controller state</a></dfn></li>
        <li><dfn><a href="http://www.w3.org/html/wg/drafts/html/master/webappapis.html#seek">seek</a></dfn></li>
        <li><dfn><a href="http://www.w3.org/html/wg/drafts/html/master/webappapis.html#media-data">media data</a></dfn></li>
        <li><dfn><a href="http://www.w3.org/html/wg/drafts/html/master/webappapis.html#text-track">text track</a></dfn></li>
        <li><dfn title="text track cue|text track cues"><a href="http://www.w3.org/html/wg/drafts/html/master/webappapis.html#text-track-cue">text track cue</a></dfn></li>
        <li><dfn><a href="http://www.w3.org/html/wg/drafts/html/master/webappapis.html#text-track-kind">text track kind</a></dfn></li>
        <li><dfn><a href="http://www.w3.org/html/wg/drafts/html/master/webappapis.html#text-track-label">text track label</a></dfn></li>
        <li><dfn><a href="http://www.w3.org/html/wg/drafts/html/master/webappapis.html#text-track-language">text track language</a></dfn></li>
        <li><dfn><a href="http://www.w3.org/html/wg/drafts/html/master/webappapis.html#text-track-mode">text track mode</a></dfn></li>
        <li><dfn><a href="http://www.w3.org/html/wg/drafts/html/master/webappapis.html#text-track-hidden">text track hidden</a></dfn></li>
        <li><dfn><a href="http://www.w3.org/html/wg/drafts/html/master/webappapis.html#text-track-loaded">text track loaded</a></dfn></li>
        <li><dfn><a href="http://www.w3.org/html/wg/drafts/html/master/webappapis.html#text-track-readiness-state">text track readiness state</a></dfn></li>
        <li><dfn><a href="http://www.w3.org/html/wg/drafts/html/master/webappapis.html#text-track-list-of-cue">text track list of cues</a></dfn></li>
        <li><dfn><a href="http://www.w3.org/html/wg/drafts/html/master/webappapis.html#list-of-text-tracks">list of text tracks</a></dfn></li>
        <li><dfn><a href="http://www.w3.org/html/wg/drafts/html/master/webappapis.html#list-of-newly-introduced-cues">list of newly introduced cues</a></dfn></li>
        <li><dfn><a href="http://www.w3.org/html/wg/drafts/html/master/webappapis.html#current-playback-position">current playback position</a></dfn></li>
        <li><dfn><a href="http://www.w3.org/html/wg/drafts/html/master/webappapis.html#time-marches-on">time marches on</a></dfn></li>
        <li><dfn><code><a href="http://www.w3.org/html/wg/drafts/html/master/webappapis.html#htmlmediaelement">HTMLMediaElement</a></code></dfn></li>
        <li><dfn><code><a href="http://www.w3.org/html/wg/drafts/html/master/webappapis.html#mediacontroller">MediaController</a></code></dfn></li>
        <li><dfn><code><a href="http://www.w3.org/html/wg/drafts/html/master/webappapis.html#texttrack">TextTrack</a></code></dfn></li>
      </ul>

      <p>
        The following interfaces are defined in [[!DOM]]:
      </p>
      <ul>
        <li><dfn><code><a href="http://www.w3.org/TR/dom/#event">Event</a></code></dfn></li>
        <li><dfn><code><a href="http://www.w3.org/TR/dom/#interface-eventtarget">EventTarget</a></code></dfn></li>
      </ul>

      <p>
        The <code><a href="http://dev.w3.org/html5/spec/webappapis.html#eventhandler">EventHandler</a></code> interface represents a callback used for <a>event handlers</a> as defined in [[!HTML5]].
      </p>

      <p>
        A <dfn>timing resource</dfn> represents a point moving along an infinite axis. This motion is defined by the position, velocity and acceleration of the point at a specific moment in time, according to some clock. Essentially, a <a>timing resource</a> represents a linear motion in real time. A <a>timing resource</a> may either be an <dfn>internal timing resource</dfn> under the control of a <a>user agent</a> or an <dfn>external timing resource</dfn> under the control of a <a>timing resource provider</a>. In both cases, the actual <a>timing resource</a> may run locally or may be an <dfn>online timing resource</dfn> hosted somewhere in the cloud.
      </p>
      <p class="note">
        A <a>user agent</a> may typically offer native implementations of <a>timing objects</a>, especially when the protocol needed is not available to Web applications. For instance, the clock synchronization mechanism defined in DVB for companion screens and streams [[DVB CSS]] uses a UDP-based protocol. A <a>user agent</a> could perhaps expose a <code>DVBCSSTimingObject</code> interface to allow Web applications to connect to a companion screen that supports this protocol.
      </p>

      <p>
        The <dfn>internal clock</dfn> is a monotonically increasing clock provided by the <a>user agent</a> (such as the one defined in [[HR-TIME]]).</li>
      </p>
      <p class="issue">
        Should we simply mandate the use of [[HR-TIME]] for the <a>internal clock</a>? This would have the advantage of clearly defining a time origin and precision for timestamp values.
      </p>

      <p>
        This document provides interface definitions using the [[!WEBIDL]] standard.
      </p>
    </section>











    <!-- EXAMPLES -->



    <section class="informative">
      <h2>Examples</h2>


      <section>
      <h3>Query</h3>
      <p> Read the current value of the timing object. </p>
      <pre class="example highlight">
      var to; // timing object
      var elem; // DOM Element
      var vector = to.query();
      elem.innerHTML = "pos:" + vector.position + " vel:" + vector.velocity + " acc:" + vector.acceleration; 
      </pre>
      </section>

      <section>
      <h3>Update</h3>
      <p>Use play and pause buttons to control the timing object.</p>
      <pre class="example highlight">
      var to; // timing object
      var playbutton;
      var pausebutton;
      playbutton.onclick = function (e) {to.update({velocity:1.0})}; // set velocity 1
      pausebutton.onclick = function (e) {to.update({velocity:0.0})}; // set velocity 0
      </pre>
      </section>

      <section>
      <h3>Polling</h3>
      <p>By querying the timing object repeatedly we can refresh time sensitive UI and demonstrate that the value of the timing object is changing predictably in time.</p>
      <pre class="example highlight">
      var to; // timing object
      var elem; // DOM Element
      setInterval(function () {
        elem.innerHTML = to.query().position;
      }, 100);
      </pre>

      <p>Alternatively, use the built in <i>timeupdate</i> event (fixed frequency).</p>
      <pre class="example highlight">
      var to; // timing object
      var elem; // DOM Element
      var to.on("timeupdate", function (r) {
        elem.innerHTML = to.query().position;
      });
      </pre>
      </section>

      <section>
      <h3>Update Event</h3>
      <p>Update operations cause abrupt changes to the timing object. Register a handler to be notified.</p>
      <pre class="example highlight">
      var to; // timing object
      var elem; // DOM Element
      to.on("update", function (e) {
        var vector = to.query();
        if (vector.velocity === 0.0 &amp;&amp; vector.acceleration === 0.0) {
          elem.innerHTML = "I'm not moving!";
        } else {
          elem.innerHTML = "I'm moving!";
        }
      });
      </pre>
      </section>

    </section>









    <!-- TIMING OBJECT -->



    <section>
      <h2>Timing Object</h2>

      <p>
        A <dfn title="timing object|timing objects">timing object</dfn> is an object that exposes a <a>timing resource</a> represented by a <a>state vector</a> to a Web application.
      </p>
      <p>
        A <a>timing object</a> has a <dfn>state</dfn> that describes the state of the connection with the <a>timing resource</a>, and an <dfn>internal vector</dfn> that represents the initial conditions of the current motion. The <a>internal vector</a> is used by the <code>query()</code> operation to calculate a snapshot of the <a>state vector</a> at the current timestamp of the clock associated with the <a>timing object</a>.
      </p>
      <p>
        A <a>timing object</a> is said to be <dfn>moving</dfn> if the velocity and/or acceleration of its <a>internal vector</a> is non-zero.
      </p>
      <p class="note">
        The <a>timing object</a> supports any motion that can be expressed in terms of a <a>state vector</a>. This means that a <a>timing object</a> is expressive enough to implement clocks, stop-watches and a variety of media controllers (at least the temporal aspects of media control).
      </p>
      <p>
        A <a>timing object</a> has a <dfn>list of timing text tracks</dfn>, which is the group of <a>timing text tracks</a> that use the <a>timing object</a> as sequencer (see <a href="#sequencer"></a>). The <a>list of timing text tracks</a> is sorted in the order <a>timing text tracks</a> are associated with the <a>timing object</a>. A <a>timing object</a> has a <dfn>list of newly introduced timing cues</dfn>, whose definition is the same as a <a>media element</a>'s <a>list of newly introduced cues</a> in [[!HTML5]].
      </p>
      <p>
        A <a>timing object</a> can have a <dfn>range</dfn>, which is an <code><a>Interval</a></code> object and represents restrictions for the positions of the <a>state vector</a> and a <dfn>current interval timeout</dfn>, which points to a scheduled timeout when set.
      </p>
      <p>
        A <a>timing object</a> can also have a <dfn>timing provider source</dfn>, which is a <code><a>TimingProvider</a></code> object that encapsulates the logic needed to represent an <a>external timing resource</a>, and a <dfn>last measured time value</dfn> that is the last timestamp value read from the <a>timing provider source</a> and is used to check the monotonicity of the clock exposed by the <a>timing provider source</a>. The <a>timing provider source</a> is initialized once and for all when the <a>timing object</a> is created.
      </p>
      <p>
        A <a>timing object</a> is associated with a <dfn title="timing object clock">clock</dfn> which is maintained by the <a>timing resource provider</a> if the <a>timing object</a> has a <a>timing provider source</a>, or is the <a>internal clock</a>.
      </p>
      <p>
        A <a>timing object</a> has a <dfn>current position</dfn>, which represents the position of the <a>timing object</a> along the unidimensional axis at the time of evaluation. When the <a>timing object</a> is <a>moving</a>, its <a>current position</a> must increase monotonically based on the velocity and acceleration of its <a>internal vector</a> per unit time of the <a>timing object clock</a>. (This specification refers to this as an <em>increase</em> but that increase could actually be a <em>decrease</em>.)
      </p>

      <p>A <a>Timing object</a> implements the following interface:</p>

      <dl title="interface TimingObject : EventTarget" class="idl">

        <dt>Constructor()</dt>
        <dd>
          <p>
            Returns a new <code><a>TimingObject</a></code> initialized with the provided initial motion conditions and possible range restrictions.
          </p>

          <dl class="parameters">
            <dt>optional TimingStateVectorUpdate vector</dt>
            <dd>The initial <a>state vector</a> to use as <a>internal vector</a>. When not specified, the timing object is initialized as a non moving point (velocity and acceleration equal <code>0.0</code>) at position <code>0.0</code>.</dd>

            <dt>optional TimingIntervalInit range</dt>
            <dd>The <a>interval</a> that constrains the motion of the <a>state vector</a>, if any.</dd>
          </dl>
        </dd>

        <dt>Constructor()</dt>
        <dd>
          <p>
            Returns a new <code><a>TimingObject</a></code> whose <a>timing provider source</a> is set to the given <code><a>TimingProvider</a></code> object.
          </p>

          <dl class="parameters">
            <dt>TimingProvider provider</dt>
            <dd>The <code><a>TimingProvider</a></code> object to use as <a>timing provider source</a>.</dd>
          </dl>
        </dd>

        <dt>readonly attribute TimingObjectState readyState</dt>
        <dd>The current state of the connection with the <a>timing resource</a>. If the <a>timing object</a> represents an <a>internal timing resource</a>, this will typically always be <code>connecting</code> or <code>open</code>. The state may take other values when the <a>timing object</a> represents an <a>external timing resource</a>.</dd>

        <dt>readonly attribute TimingInterval range</dt>
        <dd>Defines range restrictions for the position of the <a>timing resource</a>.</dd>

        <!-- Events -->

        <dt>attribute EventHandler onreadystatechange</dt>
        <dd>Event handler, of type <a>readystatechange</a>.</dd>

        <dt>attribute EventHandler onchange</dt>
        <dd>Event handler, of type <a>change</a>.</dd>

        <dt>attribute EventHandler ontimeupdate</dt>
        <dd>Event handler, of type <a>timeupdate</a>.</dd>

        <dt>attribute EventHandler onerror</dt>
        <dd>Event handler, of type <a>error</a>.</dd>

        <!-- Methods -->

        <dt>TimingStateVector query()</dt>
        <dd>Returns a snapshot of the <a>internal vector</a> evaluated against the current timestamp of the <a>timing object clock</a>.</dd>

        <dt>Promise update()</dt>
        <dd>
          Sends a request to the <a>timing resource</a> to have it update the motion based on the provided vector and return a <code>Promise</code> that the update was taken into account. The update supports null values for the provided vector's attributes. This provides a simple mechanism for tying movements together. The idea is to allow one aspect of the movement to be updated while preserving the others. For instance, <code>{position:null, velocity:value, acceleration:null}</code> means <i>update the velocity to the given value while preserving the current position and acceleration</i>.

          <dl class="parameters">
            <dt>TimingStateVectorUpdate newVector</dt>
            <dd>The new vector.</dd>
          </dl>
        </dd>
      </dl>

      <p>
        The connection with the <a>timing resource</a> that the <a>timing object</a> represents may take the following states:
      </p>
      <dl title="enum TimingObjectState" class="idl">
        <dt>connecting</dt>
        <dd>The <a>timing object</a> is attempting to establish a connection with the <a>timing resource</a> it represents. This is the initial state when a new <code><a>TimingObject</a></code> is created. This state is also used when a <code><a>TimingProvider</a></code> object is associated with the <code><a>TimingObject</a></code>.</dd>

        <dt>open</dt>
        <dd>The connection with the <a>timing resource</a> is established and communication is possible.</dd>

        <dt>closing</dt>
        <dd>The procedure to close down the connection with the <a>timing resource</a> has started.</dd>

        <dt>closed</dt>
        <dd>The connection with the <a>timing resource</a> has been closed or could not be established.</dd>
      </dl>

      <p>
        The <dfn>allowed state transitions</dfn> are:
      </p>
      <ul>
        <li>from <code>connecting</code> to any of the other states;</li>
        <li>from <code>open</code> to <code>closing</code> and <code>closed</code>;</li>
        <li>from <code>closing</code> to <code>closed</code>.</li>
      </ul>

      <section>
        <h3>Procedures</h3>

        <section>
          <h3>Create a new timing object</h3>
          <p>
            When the <code><a>TimingObject</a></code> constructor that takes an optional vector and range is invoked, the <a>user agent</a> MUST run the following steps:
          </p>
          <ol>
            <li>Let <var>timing</var> be a newly created <code><a>TimingObject</a></code>.</li>
            <li>Let <var>vectorInit</var> be the four-tuple represented by the constructor's first argument or <code>(0.0, 0.0, 0.0, t)</code> if not given, where <code>t</code> is the reading of the <a>internal clock</a> at the time of query, in seconds.</li>
            <li>Set the <a>internal vector</a> of <var>timing</var> to a newly constructed <code><a>TimingStateVector</a></code> that represents <var>vectorInit</var>.</li>
            <li>Set the <a>timing provider source</a> of <var>timing</var> to null.</li>
            <li>Let <var>rangeInit</var> be the constructor's second argument or null if not given.</li>
            <li>Set the <a>range</a> of <var>timing</var> to null.</li>
            <li>If <var>rangeInit</var> is null, set the <a>current interval timeout</a> to null.</li>
            <li>
              If <var>rangeInit</var> is not null, run the following substeps:
              <ol>
                <li>Set the <a>range</a> of <var>timing</var> to a newly constructed <code><a>Interval</a></code> that represents <var>rangeInit</var>.</li>
                <li>If the <a>range</a> does not <a title="covers">cover</a> the position of the <a>internal vector</a>, set that position to the lower bound or upper bound of the <a>range</a>, whichever is closest, and set the velocity and acceleration to <code>0.0</code> if the direction of the motion would make the position leave the <a>range</a> immediately.</li>
                <li><a>Set the internal timeout</a> of <var>timing</var>.</li>
              </ol>
            <li>Set the <a>state</a> of <var>timing</var> to <code>open</code>.</li>
            <li><a>Queue a task</a> to <a>fire a simple event</a> named <code>readystatechange</code> at <var>timing</var>.</li>
            <li>Return <var>timing</var>.</li>
          </ol>

          <p>
            When the <code><a>TimingObject</a></code> constructor that takes a <code><a>TimingProvider</a></code> is invoked, the <a>user agent</a> MUST run the following steps:
          </p>
          <ol>
            <li>Let <var>provider</var> be the constructor's argument.</li>
            <li>Let <var>timing</var> be a newly created <code><a>TimingObject</a></code> whose <a>timing provider source</a> is <var>provider</var>.</li>
            <li>Set the <a>state</a> of <var>timing</var> to <code>connecting</code>.</li>
            <li>Set the <a>range</a> of <var>timing</var> to the <code>range</code> property of <var>provider</var>.</li>
            <li>Set the <a>state</a> of the <a>timing object</a> to the <code>readyState</code> property of <var>provider</var> and, if different from <code>connecting</code>, <a>queue a task</a> to <a>fire a simple event</a> named <code>readystatechange</code> at <var>timing</var>.</li>
            <li>Set the <a>last measured time value</a> of <var>timing</var> to null.</li>
            <li>Set the <a>internal vector</a> of <var>timing</var> to the <code>vector</code> property of <var>provider</var>.</li>
            <li><a>Queue a task</a> to <a>fire a simple event</a> named <code>change</code> at <var>timing</var>.</li>
            <li><a>Observe</a> <var>provider</var>.</li>
            <li>
              When an update to the <code>readyState</code> property is observed, run the following substeps:
              <ol>
                <li>If the transition from the current <a>state</a> of <var>timing</var> to the new value is in the list of <a>allowed state transitions</a>, set the <a>state</a> of <var>timing</var> to the new value. Otherwise, set the <code>state</code> of <var>timing</var> to <code>closed</code> and <a>stop observing</a> <var>provider</var>.</li>
                <li>If the <code>error</code> property of <var>provider</var> is not null, <a>queue a task</a> to <a>fire a simple event</a> named <code>error</code> at <var>timing</var>.</li>
                <li><a>Queue a task</a> to <a>fire a simple event</a> named <code>readystatechange</code> at <var>timing</var>.</li>
              </ol>
            </li>
            <li>
              When an update to the <code>vector</code> property is observed, run the following substeps:
              <ol>
                <li>Set the <a>internal vector</a> of <var>timing</var> to the new value.</li>
                <li><a>Queue a task</a> to <a>fire a simple event</a> named <code>change</code> at the <var>timing</var>.</li>
              </ol>
            </li>
            <li>Return <var>timing</var>.</li>
          </ol>

          <p>
            When a <a>user agent</a> is required to <dfn>observe</dfn> an object and run specific steps when an update to a property is detected, it MUST start to monitor the changes made to that object in the background and run the given steps as soon as the requested change is observed.
          </p>
          <p>
            When a <a>user agent</a> is required to <dfn>stop observing</dfn> an object, it MUST stop any monitoring that was running on that object in the background.
          </p>
          <p class="issue">
            This <a title="observe">observing</a> mechanism is meant to emulate the <code>Object.observe</code> method that is being proposed in EcmaScript 7 to simplify the <code><a>TimingProvider</a></code> interface and requirements set on a <a>timing resource provider</a>, as well as to work around the fact that <code><a>TimingProvider</a></code> cannot inherit <code><a>EventTarget</a></code>. The Multi-Device Timing Community Group welcomes feedback as to whether this approach is doable in practice.
          </p>
        </section>

        <section>
          <h3>Process a query operation</h3>

          <p>
            When the <code>query</code> method is invoked on a <a>timing object</a> <var>timing</var>, the <a>user agent</a> MUST run the following steps:
          </p>
          <ol>
            <li>If the <a>state</a> of <var>timing</var> is not <code>open</code>, <a>queue a task</a> to <a>fire a simple event</a> named <code>error</code> at <var>timing</var>, return null, and abort these steps.</li>
            <li>If the <a>timing provider source</a> of <var>timing</var> is null, then let <var>t</var> be the reading of the <a>internal clock</a> at the time of query, in seconds. Otherwise, let <var>t</var> be the result of running the following substeps:
              <ol>
                <li>Let <var>t<sub>provider</sub></var> be the result of calling <code>now()</code> on the <a>timing provider source</a> object. If this throws an exception, throw the exception, and abort all remaining steps. Similarly, if the returned value is not a double, throw a <code>TypeError</code> exception, and abort all remaining steps.</li>
                <li>If the <a>last measured time value</a> of <var>timing</var> is not null and is greater than <var>t<sub>provider</sub></var> then throw an <code>OperationError</code> exception, and abort all remaining steps.</li>
                <li>Set the <a>last measured time value</a>of <var>timing</var> to <var>t<sub>provider</sub></var>.</li>
                <li>Return <var>t<sub>provider</sub></var>.</li>
              </ol>
            </li>
            <li>Let (<var>p<sub>int</sub></var>, <var>v<sub>int</sub></var>, <var>a<sub>int</sub></var>, <var>t<sub>int</sub></var>) represent the <a>internal vector</a> of <var>timing</var>.</li>
            <li>Let <var>p</var> be <var>p<sub>int</sub></var> + <var>v<sub>int</sub></var> * (<var>t</var> - <var>t<sub>int</sub></var>) + 1/2 * <var>a<sub>int</sub></var> (<var>t</var> - <var>t<sub>int</sub></var>)<sup>2</sup>.</li>
            <li>Let <var>v</var> be <var>v<sub>int</sub></var> + <var>a<sub>int</sub></var> * (<var>t</var> - <var>t<sub>int</sub></var>).</li>
            <li>Let <var>a</var> be <var>a<sub>int</sub></var>.</li>
            <li>Let <var>vector</var> be a newly created <code><a>TimingStateVector</a></code> that represents the four-tuple (<var>p</var>, <var>v</var>, <var>a</var>, <var>t</var>).</li>
            <li>Return <var>vector</var>.</li>
          </ol>

          <p class="issue">
            The mechanism that detects non-monotonic readings of a <code><a>TimingProvider</a></code> clock and throws an exception when that happens could perhaps be replaced by a procedure that asks the <a>user agent</a> to create a monotonic clock out of these non-monotonic readings and to use that clock instead. This would allow to drop the requirement on <a>timing resource provider</a> to expose a monotonic clock.
          </p>
        </section>

        <section>
          <h3>Process an update operation</h3>
          <p>
            When the <code>update</code> method is invoked on a <a>timing object</a> <var>timing</var>, the <a>user agent</a> MUST run the following steps:
          </p>
          <ol>
            <li>If the <a>state</a> of <var>timing</var> is not <code>open</code>, return a new <code>Promise</code>, reject the promise with <code>InvalidStateError</code>, <a>queue a task</a> to <a>fire a simple event</a> named <code>error</code> at <var>timing</var>, and abort these steps.</li>
            <li>Let <var>newVector</var> be the method's first parameter</li>
            <li>If the <a>timing provider source</a> of <var>timing</var> is not null, run the following substeps, and abort the remaining steps:
              <ol>
                <li>Let <var>promise<sub>provider</sub></var> be the result of calling <code>update()</code> on the <a>timing provider source</a> object with <var>newVector</var> as parameter. If the call throws an exception, return a new <code>Promise</code>, reject the promise with the exception, <a>queue a task</a> to <a>fire a simple event</a> named <code>error</code> at <var>timing</var>, and abort all remaining steps. Similarly, if the call does not return a <code>Promise</code>, return a new <code>Promise</code>, reject the promise with a <code>TypeError</code>, <a>queue a task</a> to <a>fire a simple event</a> named <code>error</code> at <var>timing</var>, and abort all remaining steps.</li>
                <li>Return <var>promise<sub>provider</sub></var>.</li>
              </ol>
            </li>
            <li>Let <var>t</var> be the reading of the <a>internal clock</a> at the time of query, in seconds.</li>
            <li>Let (<var>p<sub>int</sub></var>, <var>v<sub>int</sub></var>, <var>a<sub>int</sub></var>, <var>t<sub>int</sub></var>) represent the <a>internal vector</a> of <var>timing</var>.</li>
            <li>Let (<var>p<sub>new</sub></var>, <var>v<sub>new</sub></var>, <var>a<sub>new</sub></var>) be the three-tuple represented by <var>newVector</var>.</li>
            <li>Let <var>p</var> be <var>p<sub>new</sub></var> or <var>p<sub>int</sub></var> + <var>v<sub>int</sub></var> * (<var>t</var> - <var>t<sub>int</sub></var>) + 1/2 * <var>a<sub>int</sub></var> * (<var>t</var> - <var>t<sub>int</sub></var>)<sup>2</sup> if <var>p<sub>new</sub></var> is null.</li>
            <li>If the <a>range</a> of <var>timing</var> is not null and if it does not <a title="covers">cover</a> <var>p</var>, reject <var>promise</var> with <code>InvalidAccessError</code>, <a>queue a task</a> to <a>fire a simple event</a> named <code>error</code> at <var>timing</var> and abort these steps.</li>
            <li>Let <var>v</var> be <var>v<sub>new</sub></var> or <var>v<sub>int</sub></var> + <var>a<sub>int</sub></var> * (<var>t</var> - <var>t<sub>int</sub></var>) if <var>v<sub>new</sub></var> is null.</code>
            <li>Let <var>a</var> be <var>a<sub>new</sub></var> or <var>a<sub>int</sub></var>if <var>a<sub>new</sub></var> is null.</li>
            <li>Let <var>vector</var> be a newly created <code><a>TimingStateVector</a></code> that represents the four-tuple (<var>p</var>, <var>v</var>, <var>a</var>, <var>t</var>).</li>
            <li>Set the <a>internal vector</a> of <var>timing</var> to <var>vector</var>.</li>
            <li>If the <a>range</a> of <var>timing</var> is not null, <a>set the internal timeout</a> of <var>timing</var>.</li>
            <li><a>Queue a task</a> to <a>fire a simple event</a> named <code>change</code> at <var>timing</var>.</li>
            <li>Resolve <var>promise</var>.</li>
          </ol>
        </section>

        <section>
          <h3>Set the internal timeout</h3>
          <p>
            If <a>range</a> is specified for the timing object, e.g. <code>[0,123]</code>, the timing object must schedule a future <code>update</code> operation on itself, to ensure that the <a>range</a> is not violated.
          <p>
          <p>
            When the <a>user agent</a> is required to <dfn>set the internal timeout</dfn> of a <a>timing object</a> <var>timing</var>, it must run the following steps:
          </p>
          <ol>
            <li>If the <a>current interval timeout</a> is not null, cancel the timeout and set the <a>current interval timeout</a> to null.</li>
            <li>Given the current motion, Let <var>endpoint</var> be the <a>range</a> endpoint <code>(low|high)</code> that will be violated first, if any, and let <var>t</var> be the time when this will occur according to the <a>internal clock</a>.</li>
            <li>If <var>endpoint</var> is null, abort these steps.</li>
            <li>Set the <a>current interval timeout</a> to a newly created timeout to execute an <code>update</code> operation on <var>timing</var> with the new vector (<var>endpoint</var>, <code>0.0</code>, <code>0.0</code>) when the <a>internal clock</a> reaches <var>t</var>. <span class="note">This mechanism may be extended to support loopback</span></li> 
          </ol>

          <p class="issue">
            What would be a proper way to introduce the notion of timeout according to the <a>internal clock</a> here?
          </p>
        </section>

        <section>
          <h3>Run the sequencer</h3>
          <p>
            The <dfn>sequencer marches on</dfn> steps for a <a>timing object</a> are essentially the same steps as the <a>time marches on</a> steps for a <a>media element</a>, replacing the <a>current playback position</a> by the <code>position</code> property of the <a>state vector</a> as returned by a call to the <code>query()</code> method at the time of evaluation, and noting that <a>timing text tracks</a> do not have rules for updating the text track rendering, since their interpretation is up to the web application.
          </p>
          <p>
            A <a>timing object</a> acts as sequencer for its list of <a>list of timing text tracks</a>. As such, the intended behavior is close to the one of a <a>media element</a> with its <a>list of text tracks</a>. In particular, the <a>user agent</a> MUST run the <a>sequencer marches on</a> steps on the <a>timing object</a>in the same cases as when [[!HTML5]] requires the <a>user agent</a> to run the <a>time marches on</a> steps on a <a>media element</a>.For instance:
          </p>
          <ul>
            <li>When the <a>current position</a> of a <a>timing object</a> changes, the <a>user agent</a> MUST run the <a>sequencer marches on</a> steps.</li>
            <li>When a <a>timing object</a>'s <a>list of newly introduced timing cues</a> has new cues added, then the <a>user agent</a> MUST run the <a>sequencer marches on</a>steps.</li>
          </li>
          <p class="issue">
            This specification should of course properly document these cases and adjust steps as needed.
          </p>
        </section>
      </section>

      <section>
        <h3>Events</h3>

        <p>The following events fire on timing objects:</p>

        <table>
          <thead>
            <tr>
              <th>Event name</th>
              <th>Interface</th>
              <th>Fired</th>
            </tr>
          </thead>
          <tbody>
 
            <tr>
              <td><dfn><code>change</code></dfn></td>
              <td><a><code>Event</code></a></td>
              <td>The <a>internal vector</a> is changed. Fired after the <code>update()</code> method has returned, or when an update is received from the <a>external timing resource</a>.</td>
            </tr>
            <tr>
              <td><dfn><code>readystatechange</code></dfn></td>
              <td><a><code>Event</code></a></td>
              <td>The <code>readyState</code> attribute changed.<br/></td>
            </tr>
            <tr>
              <td><dfn><code>timeupdate</code></dfn></td>
              <td><a><code>Event</code></a></td>
              <td>Fires periodically with fixed frequency 5Hz, except when timing object is paused. This is intended as a shorthand alternative for setting up a polling-loop with setInterval, or as an emulation of the pulse-based timing model that programmers are currently used to.</td>
            </tr>
            <tr>
              <td><dfn><code>error</code></dfn></td>
              <td><a><code>Event</code></a></td>
              <td>Fired when an operation on the <a>timing object</a> cannot complete for some reason, (e.g. because of a loss of connection with the <a>timing resource</a>).</td>
            </tr>
          </tbody>
        </table>
      </section>
    </section>







    <!-- TimingProvider -->



    <section>
      <h2>Timing Provider</h2>
      <p>
        A <dfn title="timing provider object|timing provider objects">timing provider object</dfn> is an object exposed by a <a>timing resource provider</a> that encapsulates whatever logic is necessary to associate a <a>timing object</a> with an <a>external timing resource</a>.
      </p>
      <p>
        This mechanism is designed to decouple the <a>user agent</a> from any particular <a>timing resource provider</a>. In particular, this means that the protocols and logic used to identify, create or destroy an <a>external timing resource</a>, synchronize clocks and propagate motion updates to connected clients are up to the <a>timing resource provider</a>. Similarly, a <a>timing resource provider</a> may require Web applications or users to authenticate themselves before they grant them access to a particular <a>timing resource</a>.
      </p>
      <p>
        In practice, a Web application willing to use a particular <a>timing resource provider</a> needs to load the corresponding JavaScript library provided by this <a>timing resource provider</a>, create a <a>timing provider object</a> and pass that object to the <a>timing object</a> constructor.
      </p>

      <p>
        A <a>timing provider object</a> implements the following interface:
      </p>

      <dl title="callback interface TimingProvider" class="idl">
        <dt>readonly attribute TimingStateVector vector</dt>
        <dd>The <a>internal vector</a> that represents the initial conditions of the current motion.</dd>

        <dt>readonly attribute TimingInterval range</dt>
        <dd>The <a>interval</a>, if any, that defines range restrictions for the position of the <a>timing resource</a>.</dd>

        <dt>readonly attribute DOMString readyState</dt>
        <dd>The state of the object.</dd>

        <dt>double now()</dt>
        <dd>Returns the number of seconds from some arbitrary time origin defined by the <a>timing resource provider</a> when the object is created to the occurrence of the call to the <code>now</code> method.</dd>

        <dt>Promise update()</dt>
        <dd>
          Sends a request to the <a>timing resource</a> to have it update the motion based on the provided vector and return a <code>Promise</code> that the update was taken into account. The update supports null values for the provided vector's attributes. This provides a simple mechanism for tying movements together. The idea is to allow one aspect of the movement to be updated while preserving the others. For instance, <code>{position:null, velocity:value, acceleration:null}</code> means <i>update the velocity to the given value while preserving the current position and acceleration</i>.

          <dl class="parameters">
            <dt>TimingStateVectorUpdate newVector</dt>
            <dd>The new vector.</dd>
          </dl>
        </dd>
      </dl>

      <section>
        <h3>Procedures</h3>

        <section>
          <h3>Retrieve the current time</h3>
          <p>
            When the <code>now</code> method is invoked, the <a>timing resource provider</a> MUST return the number of seconds from some arbitrary time origin defined by the <a>timing resource provider</a> when the <a>timing provider object</a> is created to the occurrence of the call to the <code>now</code> method, as evaluated by some software clock maintained by the <a>timing resource provider</a>.
          </p>
          <p>
            The time values returned when calling the <code>now</code> method MUST be monotonically increasing.
          </p>
          <p>
            If the <a>external timing resource</a> that the <a>timing provider object</a> represents is hosted online, the <a>timing resource provider</a> may typically want to adjust the software clock through periodic measurements of this clock's skew against the clock of the server that hosts the resource in order to synchronize these clocks. How that synchronization is performed is up to the <a>timing resource provider</a> (see <a href="#implementation-guidelines"></a>).
          </p>
        </section>

        <section>
          <h3>Process an update operation</h3>
          <p>
            When the <code>update</code> method is invoked on a <a>timing provider object</a> <var>provider</var>, the <a>timing resource provider</a> MUST run the following steps:
          </p>
          <ol>
            <li>Let <var>promise</var> be a new <code>Promise</code>.</li>
            <li>Return <var>promise</var>.</li>
            <li>Run whatever logic is necessary to pass the update request to the <a>external timing resource</a> that <var>provider</var> represents and alter the motion conditions accordingly.</li>
            <li>If this logic succeeds, resolve <var>promise</var>. Otherwise reject <var>promise</var> with an error.</li>
          </ol>
        </section>

        <section>
          <h3>Report new conditions of the current motion</h3>
          <p>
            When the <a>timing resource provider</a> needs to report an update to the motion conditions (position, velocity or acceleration) of the <a>external timing resource</a> that a <code><a>TimingProvider</a></code> object encapsulates, it MUST set its <code>vector</code> property to a new <code><a>TimingStateVector</a></code> that represents the new conditions.
          </p>
        </section>

        <section>
          <h3>Report a state change</h3>
          <p>
            When the <a>timing resource provider</a> needs to report a change of connection state with the <a>external timing resource</a> that a <code><a>TimingProvider</a></code> object encapsulates, it MUST set its <code>readyState</code> property to the new value.
          </p>
        </section>

        <section>
          <h3>Report an error</h3>
          <p>
            When the <a>timing resource provider</a> needs to report an unrecoverable error for a <code><a>TimingProvider</a></code> object, it MUST set its <code>error</code> property to the error and set its <code>readyState</code> property to <code>closed</code>.
          </p>
          <p class="note">
            This will effectively make any <code><a>TimingObject</a></code> object that has this <code><a>TimingProvider</a></code> object as <a>timing provider source</a> enter a final <code>closed</code> state.
          </p>
        </section>
      </section>
    </section>







    <!-- TimingStateVector -->



    <section>
      <h2>State Vector</h2>

      <p>
        A <dfn title="state vector|state vectors">state vector</dfn> represents the classical four-tuple <code>(position, velocity, acceleration, time)</code> associated with the mathematical description of linear motion under constant acceleration. A <a>state vector</a> is used to represent the motion of a <a>timing resource</a>.
      </p>
      <p>
        In particular, the <a>internal vector</a> of a <a>timing object</a> is a <a>state vector</a>, the <code>query()</code> operation returns a <a>state vector</a> and the <code>update()</code> operation takes a <a>state vector</a> as parameter.
      </p>

      <p>A <a>State vector</a> implements the following interface:</p>

      <dl title="interface TimingStateVector" class="idl" data-merge="TimingStateVectorInit TimingStateVectorUpdate">
        <dt>Constructor()</dt>
        <dd>
          <p>
            The constructor takes a dictionary argument, <var>vectorDict</var>, whose content is used to initialize the new <code>TimingStateVector</code> object. The <code>timestamp</code> attribute is required, other attributes are optional and will be replaced by <code>0.0</code> if not given.
          </p>
          <dl class="parameters">
            <dt>TimingStateVectorInit vectorDict</dt>
            <dd>The initial motion along the unidimensional axis. The <code>timestamp</code> attribute is required.</dd>
          </dl>
          <p class="note">
            The constructor is only meant to be used by a <a>timing resource provider</a>, e.g. to create the <a>TimingStateVector</a> instance returned by a call to <code>query()</code>. In particular, the <a>timing resource provider</a> controls the underlying clock and thus is the only one who can compute a proper <code>timestamp</code> value.
          </p>
        </dd>

        <dt>readonly attribute double position</dt>
        <dd>Position on the unidimensional axis. The position unit is usage specific. The position may represent a point in time in seconds, a height in meters, a slide number in a slide show or something else entirely.</dd>

        <dt>readonly attribute double velocity</dt>
        <dd>Velocity along the unidimensional axis, in position unit per second.</dd>

        <dt>readonly attribute double acceleration</dt>
        <dd>Acceleration along the unidimensional axis, in position unit per squared second.</dd>

        <dt>readonly attribute double timestamp</dt>
        <dd>The moment in time when <code>position</code>, <code>velocity</code> and <code>acceleration</code> were|are|will be valid, in seconds since some arbitrary time origin. The clock used to compute the timestamp depends on whether the <a>state vector</a> represents the motion of an <a>internal timing resource</a> or of an <a>external timing resource</a>.</dd>
      </dl>

      <dl title="dictionary TimingStateVectorUpdate" class="idl">
        <dt>double position</dt>
        <dd>Position on the unidimensional axis. The position unit is usage specific. The position may represent a point in time in seconds, a height in meters, a slide number in a slide show or something else entirely.</dd>

        <dt>double velocity</dt>
        <dd>Velocity along the unidimensional axis, in position unit per second.</dd>

        <dt>double acceleration</dt>
        <dd>Acceleration along the unidimensional axis, in position unit per squared second.</dd>
      </dl>

      <dl title="dictionary TimingStateVectorInit : TimingStateVectorUpdate" class="idl">
        <dt>double timestamp</dt>
        <dd>The moment in time when <code>position</code>, <code>velocity</code> and <code>acceleration</code> were|are|will be valid, in seconds, according to the clock used by the <a>timing object</a> or <a>timing provider object</a> that needs this structure.</dd>
      </dl>

      <section>
        <h3>Procedures</h3>

        <section>
          <h3>Create a new state vector</h3>
          <p>
            When the <code>TimingStateVector</code> constructor is called, the <a>user agent</a> MUST run the following steps:
          </p>
          <ol>
            <li>Let <var>vector</var> be a newly created <code><a>TimingStateVector</a></code>.</li>
            <li>Let (<var>p<sub>init</sub></var>, <var>v<sub>init</sub></var>, <var>a<sub>init</sub></var>, <var>t<sub>init</sub></var>) be the four-tuple represented by the constructor's first argument.</li>
            <li>If <var>t<sub>init</sub></var> is null, throw an <code>InvalidParameter</code> exception and abort these steps.</li>
            <li>For each other variable, if the value is null, set it to <code>0.0</code>.</li>
            <li>Initialize <var>vector</var> so that it represents the four-tuple (<var>p<sub>init</sub></var>, <var>v<sub>init</sub></var>, <var>a<sub>init</sub></var>, <var>t<sub>init</sub></var>).</li>
            <li>Return <var>vector</var>.</li>
          </ol>
        </section>
      </section>
    </section>




    <!-- INTERVAL -->



    <section>
      <h2>Interval Object</h2>
      <p>
        An <dfn>interval</dfn> is a representation of a mathematical interval of real numbers. Attributes <code>low</code> and <code>high</code> are endpoints defining the interval. <code>(low &lt;= high)</code> is always true. If <code>(low === high)</code> the interval is a singular point. <code>low</code> and <code>high</code> may be set to <code>Infinity</code> or <code>-Infinity</code> to represent infinite intervals. Attributes <code>lowInclude</code> and <code>highInclude</code> determine whether endpoints <code>low</code> and <code>high</code> are included or excluded from the interval.
      </p>


      <dl title="interface TimingInterval" class="idl" data-merge="TimingIntervalInit">
        <dt>Constructor()</dt>
        <dd>
          <p>
            The constructor takes a dictionary argument, <var>intervalDict</var>, whose content is used to initialize the new <code>TimingInterval</code> object.
          </p>
          <dl class="parameters">
            <dt>TimingIntervalInit intervalDict</dt>
            <dd>Information about the interval to create.</dd>
          </dl>
        </dd>

        <dt>readonly attribute unrestricted double low</dt>
        <dd>The lower bound of the interval.</dd>

        <dt>readonly attribute unrestricted double high</dt>
        <dd>The upper bound of the interval.</dd>

        <dt>readonly attribute boolean lowInclude</dt>
        <dd>Whether the lower bound is included in the interval.</dd>

        <dt>readonly attribute boolean highInclude</dt>
        <dd>Whether the upper bound is included in the interval.</dd>

        <dt>boolean covers (unrestricted double value)</dt>
        <dd>Returns true if the interval covers the given value.</dd>
      </dl>

      <dl title="dictionary TimingIntervalInit" class="idl">
        <dt>double low</dt>
        <dd>The lower bound of the interval.</dd>

        <dt>double high</dt>
        <dd>The upper bound of the interval.</dd>

        <dt>boolean lowInclude</dt>
        <dd>Whether the lower bound is included in the interval.</dd>

        <dt>boolean highInclude</dt>
        <dd>Whether the upper bound is included in the interval.</dd>
      </dl>

      <section>
        <h3>Procedures</h3>

        <section>
          <h3>Create a new interval</h3>

          <p>
            When the <code><a>Interval</a></code> constructor is invoked, the <a>user agent</a> MUST run the following steps:
          </p>
          <ol>
            <li>Let <var>interval</var> be a newly created <code><a>Interval</a></code>.</li>
            <li>Let <var>intervalDict</var> be the constructor's first argument.</li>
            <li>If <var>intervalDict.low</var> is null, set it to <code>-Infinity</code>.</li>
            <li>If <var>intervalDict.high</var> is null, set it to <code>Infinity</code>.</li>
            <li>If <var>intervalDict.low</var> is greater than <var>intervalDict.high</var>, swap <var>intervalDict.low</var> with <var>intervalDict.high</var> and swap <var>intervalDic.lowInclude</var> with <var>intervalDict.highInlude</var>.</li>
            <li>Initialize the attributes of <var>interval</var> to the computed values of <var>intervalDict</var>.</li>
            <li>Return <var>interval</var>.</li>
          </ol>
        </section>

        <section>
          <h3>Cover a position</h3>
          <p>
            When the <code>covers</code> method is invoked on an <a>interval</a>, the <a>user agent</a> MUST evaluate whether the <a>interval</a> <a>covers</a> the provided value and return the result.
          </p>
          <p>
            When the <a>user agent</a> is required to evaluate whether an <a>interval</a> <dfn>covers</dfn> a position value, it MUST run the following steps:
          </p>
          <ol>
            <li>Let <var>value</var> be the position to evaluate.</li>
            <li>If <var>value</var> is smaller than the <code>low</code> attribute of the <a>interval</a>, return <code>false</code>, and abort these steps.</li>
            <li>If <var>value</var> equals the <code>low</code> attribute of the <a>interval</a> and the <code>lowInclude</code> attribute is <code>false</code>, return <code>false</code>, and abort these steps.</li>
            <li>If <var>value</var> is greater than the <code>high</code> attribute of the <a>interval</a>, return <code>false</code>, and abort these steps.</li>
            <li>If <var>value</var> equals the <code>high</code> attribute of the <a>interval</a>, return <code>false</code>, and abort these steps.</li>
            <li>Return true.</li>
          </ol>
        </section>
      </section>
    </section>


    <section>
      <h3>Associating media elements with a timing object</h3>
      <p class="note">
        If this specification progresses along the standardisation track, this section should be merged in a future version of [[!HTML5]].
      </p>
      <p class="issue">
        The procedures below are incomplete, some of them are described as updates to be made to procedures defined in [[!HTML5]], and some procedures are missing. The goal is to define a <a>timing object</a> as a <code><a>MediaController</a></code> without requiring the <a>report the controller state</a> part and with prose to convey the need for a <a>user agent</a> to keep trying to bring the <a>media element</a> up to speed with its <a>timing object</a> when it cannot follow the motion the <a>timing object</a> imposes. Before dwelving into details, the Multi-Device Timing Community Group welcomes feedback on the overall approach proposed here.
      </p>
      <p>
        This section specifies an extension of <a>media elements</a> that allows them to use a <a>timing object</a> as a <a>media timeline</a> source.
      </p>
      <p>
        From the perspective of a <a>media element</a>, a <a>timing object</a> may be viewed as a <code><a>MediaController</a></code> with one notable exception: when it is slaved to a <a>timing object</a>, a <a>media element</a> cannot pause a <a>timing object</a>, even if it becomes stall.
      </p>
      <p>
        A <a>media element</a> can have a <dfn>current timing source</dfn>, which is a <code><a>TimingObject</a></code>, that imposes the <a>media timeline</a> and associated clock that the <a>media element</a> uses.
      </p>

      <dl title="partial interface HTMLMediaElement" class="idl">
        <dt>attribute TimingObject timingsrc</dt>
        <dd>Get/Set the <code><a>TimingObject</a></code> object associated with this media element.</dd>
      </dl>

      <section>
        <h3>Procedures</h3>
        <section>
          <h3>Associate with a timing object</h3>
          <p>
            The <code>timingsrc</code> attribute on a <a>media element</a> MUST, on getting, return the <a>current timing source</a>, if any, or null otherwise. On setting, the <a>user agent</a> MUST run the following steps:
          </p>
          <ol>
            <li>Let <var>m</var> be the <a>media element</a> in question.</li>
            <li>Let <var>old controller</var> be <var>m</var>'s <a>current media controller</a>, it if currently has one, and null otherwise.</li>
            <li>Let <var>m</var> have no <a>current media controller</a>, if it currently has one.</li>
            <li>Remove the elements's <code>mediagroup</code> content attribute, if any.</li>
            <li>Let <var>m</var> have no <a>current timing source</a>, it if currently has one.</li>
            <li>If the new value is null, then jump to the <i>update controller</i> step below.</li>
            <li>Let <var>m</var>'s <a>current timing source</a> be the new value.</li>
            <li>Let <var>new timing</var> be <var>m</var>'s <a>current timing source</a>.</li>
            <li><a>Bring the media element up to speed with its new timing source</a>.</li>
            <li><i>Update controller</i>: If <var>old controller</var> is not null and still has one or more <a>slaved media elements</a>, then <a>report the controller state</a> for <var>old controller</var>.</li>
          </ol>

          <p>
            When a <a>media element</a> has a <a>current timing source</a>, its <a>effective playback rate</a> is the <code><a>TimingObject</a></code>'s <a>internal vector</a>'s velocity.
          </p>
        </section>

        <section>
          <h3>Set the current media controller</h3>
          <p>
            The procedures defined in [[!HTML5]] that update the <a>current media controller</a> should be updated to include the following step before the <a>current media controller</a> is set:
          </p>
          <ol>
            <li>Let <var>m</var> have no <a>current timing source</a>, if it currently has one.</li>
          </ol>
        </section>

        <section>
          <h3>Set the current position</h3>
          <p>
            The procedure defined in [[!HTML5]] that prevent setting <code>currentTime</code> when the <a>media element</a> has a <a>current media controller</a> should be updated to also prevent setting the attribute when the <a>media element</a> has a <a>current timing source</a>.
          </p>
          <p class="note">
            The <code>playbackRate</code> attribute has no effect when the <a>media element</a> has a <a>current timing source</a>, the velocity of the <a>state vector</a> of the <a>current timing source</a> is used instead in that situation.
          </p>
        </section>

        <p class="issue">
          Should the <code>play</code>, <code>pause</code> and other commands be mapped to <code>update</code> requests on the <code><a>TimingObject</a></code>?
        </p>

        <section>
          <h3>Bring a media element up to speed with its timing source</h3>
          <p>
            When the <a>user agent</a> is to <dfn>bring the media element up to speed with its new timing source</dfn>, it MUST run the following steps:
          </p>
          <ol>
            <li>Let <var>m</var> be that <a>media element</a>.</li>
            <li>Let <var>timing</var> be that timing source.</li>
            <li>Let (<var>p</var>, <var>v</var>, <var>a</var>, <var>t</var>) be the result of calling <code>query</code> on <var>timing</var>.</li>
            <li>If <var>m</var> cannot be <a title="seek">seeked</a> to <var>p</var> relative to <var>m</var>'s timeline because <a>media data</a> is not yet available, <a>queue a task</a> to <a>bring the media element up to speed with its new timing source</a> and abort these steps.</li>
            <li><a>Seek</a> <var>m</var> to <var>p</var> relative to <var>m</var>'s timeline.</li>
          </ol>
          <p class="issue">
            The <a>seek</a> procedure needs to be redefined here, since it may update the final playback position which must not happen here.
          </p>
        </section>
      </section>
    </section>







    <section>
      <h3>Sequencer</h3>
      <p>
        A <dfn title="timing text track|timing text tracks">timing text track</dfn> is a <a>text track</a> that can be associated with a <a>timing object</a>, which acts as sequencer for the <a>text track cues</a> that compose the <a>text track</a>. As such, a <a>timing text track</a> has a <dfn>current sequencer</dfn> which is the <a>timing object</a> that it is associated with.
      </p>
      <p class="note">
        As opposed to a <a>text track</a>, a <a>timing text track</a> is not and cannot be associated with a <a>media element</a>. The interpretation of a <a>timing text track</a>'s <a>text track cue</a> is up to the Web application in particular.
      </p>
      <p class="issue">
        Is inheriting from <a>TextTrack</a> as proposed below the right approach? It it tempting to extend <a>TextTrack</a> as done for the <a>HTMLMediaElement</a> above. However <a>TextTrack</a> does not expose a constructor and adding an <code>addTextTrack</code> method to <a>TimingObject</a> (similar to the one on <a>HTMLMediaElement</a>) is not consistent with a <a>timing object</a> that objects can associate with.
      </p>
      <dl title="interface TimingTextTrack : TextTrack" class="idl">
        <dt>Constructor()</dt>
        <dd>
          Returns a new <code><a>TimingTextTrack</a></code>.
          <dl class="parameters">
            <dt>TextTrackKind kind</dt>
            <dd>The <a>kind of track</a>.</dd>
            <dt>optional DOMString label = ""</dt>
            <dd>The <a>text track label</a>.</dd>
            <dt>optional DOMString language = ""</dt>
            <dd>The <a>text track language</a>.</dd>
          </dl>
        </dd>

        <dt>attribute TimingObject timingsrc</dt>
        <dd>Get/Set the <code><a>TimingObject</a></code> object associated with this timing text track.</dd>
      </dl>

      <section>
        <h3>Procedures</h3>

        <section>
          <h3>Create a new timing text track</h3>
          <p>
            When the <code><a>TimingTextTrack</a></code> constructor is invoked, the <a>user agent</a> MUST run the following steps:
          </p>
          <ol>
            <li>Create a new <code><a>TimingTextTrack</a></code> object.</li>
            <li>Create a new <a>timing text track</a> corresponding to the new object, and sets its <a>text track kind</a> to <var>kind</var>, its <a>text track label</a> to <var>label</var>, its <var>text track language</var> to language, its <a>text track readiness state</a> to the <a>text track loaded</a> state, its <a>text track mode</a> to the <a>text track hidden</a> mode, and its <a>text track list of cues</a> to an empty list.</li>
            <li>Return the new <code><a>TimingTextTrack</a></code> object.</li>
          </ol>
        </section>

        <section>
          <h3>Associate with a timing object</h3>
          <p>
            The <code>timingsrc</code> attribute, on getting, MUST return the <a>current sequencer</a> of the <a>timing text track</a>, if any, or null otherwise. On setting, the <a>user agent</a> MUST run the following steps:
          </p>
          <ol>
            <li>Let <var>track</var> be the <a>timing text track</a> in question.</li>
            <li>Let <var>old timing</var> be <var>track</var>'s <a>current sequencer</a>, if any, or null otherwise.</li>
            <li>Let <var>track</var>'s <a>current sequencer</a> be the new value.</li>
            <li>Let <var>new timing</var> be <var>track</var>'s <a>current sequencer</a>.</li>
            <li>
              If <var>old timing</var> is not null, run the following substeps:
              <ol>
                <li>Remove <var>track</var> from <var>timing</var>'s <a>list of timing text tracks</a>.</li>
                <li>Run the <a>time marches on</a> algorithm on <var>timing</var>.</li>
              </ol>
            </li>
            <li>
              If <var>new timing</var> is not null, run the following substeps:
              <ol>
                <li>Add <var>track</var> to <var>timing</var>'s <a>list of timing text tracks</a>.</li>
                <li>Run the <a>time marches on</a> algorithm on <var>timing</var>.</li>
              </ol>
            </li>
          </ol>
        </section>
      </section>
    </section>


    <section class="informative">
      <h3>Implementation guidelines</h3>

      <p>
        Distributed synchronization is a main use case that a <a>user agent</a> or a <a>timing resource provider</a> may enable. <a>Timing objects</a> running on different devices will be synchronized if they are associated with the same online <a>timing resource</a>. To achieve precise and reliable synchronization across the Internet, the implementation needs to address two distinct issues: the synchronization of motion updates and the synchronization of clocks. A brief introduction to a specific solution is given below. Details are available in [[MSV]].
      </p>
      <p class="note">
        Guidelines below are phrased against <a>timing objects</a> but the guidelines apply to <a>timing provider objects</a> as well.
      </p>

      <section>
        <h3>Motion update synchronization</h3>

        <p>
          If an <a>online timing resource</a> is updated, effects must apply equally to all connected <a>timing objects</a> as quickly as possible, including to the <a>timing object</a> on which the update request might have been issued. This has implications for the processing of update requests. Local timing objects should simply forward the request (i.e. the <a>state vector</a>) across the network to the <a>online timing resource</a>, where the request will be processed. Effects (i.e. the new <a>state vector</a>) will be multicast by the <a>online timing resource</a> to all connected <a>timing objects</a>, finally triggering a <code>change</code> event on these objects. Queries are always resolved locally, using the last <a>state vector</a> received from the server.
        </p>

        <p>
          Note that this strategy does not guarantee that <a>timing objects</a> receive the update notification at exactly the same time. It is possible to mask the differences in network latency by introducing an additional delay, but note that this might hurt the user experience.
        </p>
      </section>

      <section>
        <h3>Clock synchronization</h3>
        <p>
          Ideally, if multiple <a>timing objects</a> that represent the same <a>online timing resource</a> are queried at the exact same moment, they should return the same <a>state vector</a> (same position, velocity and acceleration). This requires that the local clock associated with the <a>timing object</a> be synchronized with that of the <a>online timing resource</a>.
        </p>
        <p>
          As synchronized system clocks is not a valid assumption in the Web environment, it follows that clock synchronization must be resolved as part of the communication between <a>timing objects</a> and the <a>online timing resource</a>. To do this, <a>timing objects</a> should maintain a software clock that is continuously synchronized with the system clock of the <a>online timing resource</a>. This may be achieved through periodic exchange with the <a>online timing resource</a> to evaluate the clock skew, taking into account the round-trip time (RTT) of these exchanges to improve the measurements. Using this evaluation, <a>timing objects</a> can tranform <a>state vectors</a> with respect to their own local clock.
        </p>
        <p>
          Clock synchronization can be very fast. Stable estimates may be reached within fractions of a second. Implementations may for instance use an open Web sockets [[WEBSOCKETS]] connection to minimize the latency between <a>timing objects</a> and the <a>online timing resource</a>. If implemented correctly on both ends, this approach provides a basis to achieve &lt; 10ms media synchronization across the Internet.
        </p>
      </section>
    </section>
  </body>
</html>
